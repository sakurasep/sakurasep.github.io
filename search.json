[{"title":"EmbyBot使用指南","path":"/posts/emby_bot/","content":"使用教程1. 添加 TGBot九月的 EmbyBot 点击频道入口或者群组入口加入交流群 此时机器人的聊天框就变成可输入的，输入/start开始使用 2. 使用指南2.1 账号注册当出现以下图片时，代表着 Bot 已经绑定了你的电报账号。 此时输入/start就可以打开用户面板，进行账号的注册。 根据要求输入想要注册的账号即可完成注册。 提示 注册成功会显示账号密码等信息，请记住安全码！ 此时再输入/start，可以看到已经变成了新的页面。可以在用户功能-重置密码中修改媒体库账号的密码 2.2 点播 点播最好点已经完结的剧集，新番通常不会有合集资源，需要一个个去下载 点击求片，输入想要看的片名就可以自动下载了。根据描述输入你想看的资源，回复编号开始下载。 具体的文件名代表的意义可以去问 DeepSeek 或者看这一期视频。 此时如果显示添加下载队列成功，表明已经开始下载。 当影片入库完成后会弹出以下提醒，告诉你可以进行观看了。 但是由于这里的入库是指的在我的服务器已经入库完成，但是由于媒体库使用的是 strm 播放云盘资源的播放方式，所以需要等待资源上传完成才能够观看，速度快的话十分钟，慢的话就难说了。 2.3 媒体库搜索在媒体库交流群组中@机器人即可唤出搜索面板。（其实从播放客户端直接搜索更方便） 点击收藏即可将该资源加入媒体库账号的收藏夹。 3. 连接媒体库安卓平台 记得在yamby设置里打开mpv播放器，否则一些内嵌字幕显示会有问题 安卓平台推荐使用 Yamby WindowsWindows 版本下载 密码 0421 TV电视端挺麻烦的，一般来说是下载安装包到 U 盘然后手动安装 TV 版本下载 密码 0421 Apple苹果全家桶都建议使用 Vidhub","tags":["Emby","动漫","TGBot"],"categories":["媒体库"]},{"title":"动漫年鉴 - BDRip","path":"/posts/anime-collect-bdrip/","content":"对于入坑作是 Re0 时代的二次元，很多老番只是听过它们的大名，但是却一直没机会去观看，正巧最近整理媒体库，打算根据泛式的新番时光机来补番。同时，我的朋友与同学也提供了不少有趣的动漫，这些内容将分为不同板块存在 Onedrive 中，后续有资金后会购入硬盘存在本地。 Tips: 资源来自 U2 等 PT 站点，故不开放注册，本媒体库仅用于朋友同学之间交流使用 新番时光机 - 泛式2010 年 10 月新番缘之空爆漫王 S01爆漫王 S02爆漫王 S03 2011 年 1 月新番无限斯特拉托斯 动漫年鉴 - NotionNotion 笔记 Azuki咔咔 总表是使用的年份进行记录 表格记录了已经收录的动漫，可以查看压制组等具体的内容","tags":["Emby","动漫","BDRip"],"categories":["媒体库"]},{"title":"Unraid中如何使得容器获取IPV6地址","path":"/posts/Unraid-IPV6/","content":"前言对于我们现在很多地区的运营商来说，公网 IPV4 是极其难去申请的，就算可以申请到，也会让你加不少钱改套餐，对于普通用户来说有些划不来。IPV6 是连通公网的一个不错的方法，只需要给当地运营商的运维打个电话，把光猫拨号改为桥接，再从路由器中拨号并打开 IPV6 功能，此时便可以轻松将你的设备开放给公网。 对于开放在公网的设备来说，IPV6 的复杂程度以及动态变更的特点，让公网的设备面对暴露的风险时还是有一定的防御能力，但是我仍然不推荐将所有端口都开放到公网，以免出现安全问题。 一、路由器的设置不同的路由器的设置内容略有不同，这里我是 TP-LINK 的主路由，所以暂时先给出该型号路由器配置的详细图文教程。 只要记住一点，Unraid 目前可以通过 DHCPv6 或者 SLAAC 获取到 IPV6 地址，但是 Unraid 的 Docker 服务并不可以直接使用 DHCPv6 所分配的 IPV6 地址，而且 Android 设备貌似也不能使用 DHCPv6，所以最好还是使用 SLAAC 进行分配。 TP-LINK 路由器1.1 关闭 IPV6 桥接模式首先需要关闭 IPV6 桥接模式，如果你的 TP-LINK 路由器为二级路由，那就开启桥接模式。 1.2 路由拨号与获取前缀授权在确定光猫端设置为桥接之后，在路由器进行拨号。 这里复用 IPV4 的拨号链路，因为如果这里仍然拨号就会产生冲突。 前缀授权 前缀授权也就是本地路由向 ISP 运营商的 DHCP 获取一个 IPV6 地址的前缀，然后本地就可以继续根据这一个 IPV6 地址继续分配给其他设备或创建子网 1.3 设置 SLAAC 分配 IPV6 地址给其他设备设置一下 LAN 口相关设置，首先选择 WAN 口的前缀授权接口，下一步选择 SLAAC 对其他设备授权 IPV6 地址。 二、Unraid 的设置我这里使用的是 Unraid 6.11.5，Unraid 不同版本在某些设置可能存在差异，如有问题请在评论区提出。 Unraid 网络设置在修改网络设置前，需要关闭 Docker 服务以及虚拟机服务。 设置 Docker 应用的网络类型Unraid 提供的 Docker 网络模式主要有以下几种： bridge： 默认的网络模式。容器连接到一个虚拟的桥接网络，可以通过桥接网络相互通信。 容器通过NAT共享主机的IP地址。 host： 容器与主机共享网络命名空间，使用主机的IP地址和端口。 容器的端口直接暴露在主机上，没有NAT。 none： 容器没有网络连接，仅有回环接口（lo）。 适用于不需要网络的应用或自定义网络配置。 custom： 自定义网络模式，允许用户创建和配置自己的桥接或macvlan网络。 可以通过Unraid的网络设置界面进行配置，适用于需要特定网络设置的应用。 custom 模式（推荐） 等待容器启动完成，我们打开控制台，输入命令ifconfig查看容器是否成功获取了 IPV6 地址。如下图所示，eth0 网卡已经成功获取了公网 IPV6 地址。 host 模式 我这里因为 AutoBangumi 没法连接 custom 模式下的 qBittorrent，所以只能使用 host 模式，一般来说不建议使用 host 模式直接暴露 Unraid 的 IPV6 地址，毕竟在 qBittorrent 中是可以直接看到 IPV6 地址的。 等待容器启动完成，我们打开控制台，输入命令ifconfig查看容器是否成功获取了 IPV6 地址。如下图所示，br0 网卡已经成功获取了公网 IPV6 地址。 应用的具体设置qBittorrent在 qBittorrent 的设置-高级中修改网络接口为控制台中查询到的 Unraid 的网卡。具体的网络接口可以从 Unraid 的网络设置-路由表中看到。 此外，qBittorrent 绑定到的 IP 地址选择所有地址，只要你的 NAT 类型不是太差，IPV4 还是可以连接到的，只是上传的连通性会变得很差。 后记目前我个人不太经常使用 IPV6，毕竟在外面的话，除了流量是 IPV6，其他地方的网络很多是没有开启 IPV6 的，所以在外面访问家里的服务我使用的是 Tailscale，感觉还是挺不错的，基本能跑满。 这篇文章算是我自己使用 Unraid 中遇到的问题，然后随手写的解决方案，后续也会继续写一些有趣的文章。","tags":["Unraid"],"categories":["Unraid"]},{"title":"云服务器的简单使用指南","path":"/posts/ZeroLinux/","content":"一、选购服务器关于在本地使用虚拟机创建Linux服务器和使用云服务器，两者的区别在于你的应用方向。本地的服务器通常有着较高的性能，可以挂载更多的服务，承接更高的性能需求。对于云服务器，更多的价值在于公网 IP，对于我们个人来说，面向互联网的服务多数资源消耗较少，因此花钱买到公网 IP 更符合我对个人使用云服务器的看法。 国内有不少的云服务厂商，他们的价格和服务器配置差距挺大，作为一个初次使用云服务的用户，很多厂商都可以白嫖到试用机会。建议在确定好要购买长期使用之前，先试用一下，感受一下网页控制台是否足够方便，是否符合自己的使用习惯。 当你选定一家云服务商后，这里建议域名注册，备案等等服务也都在同一家云服务商进行购买。例如我个人的服务器，CDN，对象存储服务都是使用的腾讯云，这样使用起来更方便，不用切换其他云服务的控制台。 最后注意一下，一定要关注各家云服务厂商的优惠活动，建议首选知名的云服务商，以便保证后续服务。 以下是我的服务器运行情况 二、安装基本环境整篇文章都将使用华为云的 2H2G 服务器进行测试演示，一年只需要 36 元，感觉十分合适，如果活动还在是很推荐入手的。 1. 安装 SSH 工具SSH 工具有很多，这里我在 macOS 上经常使用的是FinalShell，个人感觉还是很方便的，界面也很清晰。 FinalShell SSH工具 当然在 windows 端我更推荐使用MobaXterm，GitHub 上有位大佬精心做了汉化。 FinalShell SSH工具 三、服务器基本配置1. 镜像选择与重置密码镜像的选择其实差别并不是很大，Ubuntu 和 Debian 二选一就可以了。 建议在装完系统后手动重置一下密码，并牢记此密码。 2. 配置SSH工具在 Finalshell 中配置 SSH 连接，在主机处填入云服务器的公网 IP，用户名默认为 root。 连接成功如下所示，可以看到 Finalshell 能够显示服务器基本的负载信息，并且可以在软件底部实现上传操作。 四、 安装面板4.1 常见面板介绍相比于使用终端进行操作，对于小白来说，使用面板更加方便。 目前有两个比较流行的面板，宝塔和 1Panel，宝塔稳定性更强，但是界面含有不少的付费要素，且必须绑定宝塔账号。1Panel的界面干净整洁，在去年的使用中出现了几个小 bug，稳定性相较于宝塔逊色一点。本篇文章将会使用 1Panel 进行演示。 宝塔面板 1Panel 在宝塔和 1Panel 之外还有一些其他的面板，朋友们也可以尝试一下。 耗子面板 4.2 一键安装面板在终端输入以下命令安装 1Panel 面板。 curl -sSL https://resource.fit2cloud.com/1panel/package/quick_start.sh -o quick_start.sh sudo bash quick_start.sh 设置面板的安装目录，这里保持默认即可。 由于国内连接 Docker 服务不够稳定，后续在线安装 Docker 服务可能会出现错误提示，请不要在意，整体的下载速度较慢。 Docker 安装完成后，安装程序会让你选择访问面板的端口，这里建议更换默认端口为一个你容易记住的端口。 设置完成端口后，需要设置一个安全入口，同样设置一个你能够记住的字符串。 后续需要配置面板管理的用户名和密码，请尽量保证密码的复杂，不要使用简单密码。 当安装程序结束后，你将可以看到外网访问地址，此时请在云服务商的安全组策略中放行刚刚设置的面板端口。这里以华为云为例，在策略组的入方向规则中放行端口。 此时访问http://ip地址:端口/安全入口字符串就可以进入面板。 五、 Docker 相关配置5.1 Docker 镜像加速配置目前国内不少 Docker 的镜像站都不再提供服务，这里我提供一些正常运营的 Docker 镜像站。 5.1.1 使用终端设置镜像源在终端使用命令行，设置镜像源。 sudo tee /etc/docker/daemon.json EOF registry-mirrors: [加速镜像1]EOFsudo systemctl daemon-reloadsudo systemctl restart docker 5.1.2 在面板中修改镜像源在 1Panel 面板的容器 - 配置中添加镜像加速地址。 可以直接使用的镜像站 以下是可以直接使用的镜像源，如果其中有源失效，请及时告知博主。 如果你有比较可靠的镜像源，也请在评论区留言，感谢！ ## 1Panelhttps://docker.1panel.live## DaoCloud/public-image-mirrorhttps://docker.m.daocloud.io## 耗子面板公益加速https://hub.rat.dev/## dockerhub.icuhttps://dockerhub.icu## docker.awsl9527.cnhttps://docker.awsl9527.cn## AtomHubhttps://atomhub.openatom.cn 需要特定条件才能使用的镜像站 仅支持阿里云相关云产品使用，每一个账号有独立的镜像地址，如果购买的云服务商为阿里云，那就可以使用阿里云提供的 Docker 镜像加速。 容器镜像服务 5.1.3 测试拉取镜像在容器 - 镜像 - 拉取镜像中测试拉取linuxserver/qbittorrent镜像。 由于镜像站不会镜像 DockerHub 全部的镜像，有些冷门镜像无法拉取很正常。 六、ShellClash 代理配置由于例如 GitHub，DockerHub 等服务在国内的服务器上难以访问，还是建议各位在服务器上安装一个简易的 Clash，方便克隆 Github 仓库以及拉取 Docker 镜像。 6.1 安装 ShellClash在终端执行以下命令 export url=https://fastly.jsdelivr.net/gh/juewuy/ShellCrash@master wget -q --no-check-certificate -O /tmp/install.sh $url/install.sh bash /tmp/install.sh source /etc/profile /dev/null 选择公测版 - 在usrshare目录安装 - 确定，一键安装 ShellClash 6.2 配置 ShellClash在终端输入 clash 进入管理界面，首先选择Linux设备代理本机流量 然后开启公网访问dashboard面板，以便管理 clash 的配置文件 设置面板访问密钥，并开启自动任务 选择在线生成配置文件，并在之后的提示中导入订阅链接。 此时就可以愉快的访问 Github 与 Docker Hub了。 为了方便管理，这里建议安装 dashboard 面板 此时在安全组放行 9999 端口，即可访问后台管理面板公网IP:9999/ui 6.3 测试以及注意事项可以看到，当你配置镜像加速的时候，如果可以从镜像站拉取到镜像，会优先从镜像站下载。 如果到了实在没有镜像站可用的时候，或者镜像站并没有对应的镜像，便可以通过代理下载。 注意，当不需要使用代理的时候，请及时关闭代理，同时建议关闭 shellclash 的开机自启，以免影响服务器其他服务正常的运行。","tags":["零基础","Linux"],"categories":["技术分享"]},{"title":"基于UA3F的校园网防检测指南","path":"/posts/UA3F/","content":"前言作为QFNU曾在北公寓住宿过的学生，当转入校内宿舍楼居住的时候马上体会到了网络带来的不便，之前网线入户带来的便捷取而代之的是移动加私企垄断的局面。 之前有竞争的时候，移动 10 元 100 兆宽带或是联通 300 兆宽带都能满足不同的需要，对于宿舍 6-8 人的需求，100 兆在非下载资源的时间段是绰绰有余的，对于学生来说资费也很合适，毕竟出了宿舍开热点用流量还是更加方便。 对于新校区将校园网普及到宿舍，这本身是一件好事，可是被无良公司当成了赚钱的工具。当初承诺的每一个人单设备独享 100 兆带宽，可是一到晚上速度就会降到 20 兆到 30 兆的速度。让我们计算一下，一个宿舍楼的出口带宽是 80Gbps，一个宿舍楼有11层楼，一层楼差不多30个宿舍，一个宿舍6个人，11 x 30 x 61980，按照 2000 人来算，如果所有人都办理校园网外加全部都下载资源跑满下行，每个设备都应该有 40 兆的带宽。 其次是所谓的安全问题，校园网采用的是锐捷的系统，能够清楚地知道哪一个 IP 访问了什么内容，这样来进行管理时没有问题的。然而防共享检测将每个账号的使用设备控制在 2 个，电脑加手机，多的平板就不能上网了。校园网之前说可以提供设备的 mac 地址来扩展设备数量，但是直到现在都没有实行，纯纯的画大饼。就算放开共享，现在已经实现了 ap 入户，每一个宿舍都有一个独立的 ap，后台仍然可以精准定位异常访问，精准到某个宿舍，难道很难吗。共享检测做的这么严密，其实不过是垄断之后想要狠狠地赚钱罢了。 好了，作为毕业的老东西，哥们终于可以分享如何绕过校园网的检测，实现宿舍上网自由。 注意事项，本教程适用于锐捷 web 认证，其他认证请加 TG 群 @crack_campus_network 讨论 以下是锐捷 web 认证网页端，如果确定是此类型的校园网认证，可以尝试本教程内容 一、准备工作 一台支持 openwrt 的设备 一个校园网账号 一个较为稳定的机场 二、UA3F + Clash 在 openwrt 的安装对于 QFNU 的共享检测机制，是检测 UA 和腾讯系流量，因此传统的 UA2F 会遇到经常性的封禁问题，一旦连接路由的设备出现了访问腾讯系应用，就可能触发延迟封禁（不会秒封，猜测是有阈值），由于 UA2F 不能与 Clash 等代理共存，所以 UA2F 不能很好的处理锐捷针对腾讯流量的检测。但是好在，UA3F 诞生了。 UA3F 作为一个 SOCK5 服务，可以直接与 Clash 进行交流，我们让 Clash 接管设备的所有流量，根据规则将 http 协议的链接走 UA3F 进行 UA 的修改，然后将其他特殊的流量走代理加密，剩余不需要处理的流量直连即可。 1. 挑选合适的设备UA3F 支持常见的架构设备，只要你的设备支持 openwrt，内存大于 256 兆，基本就可以使用。这里我个人推荐购买一台 RAX3000M（20231027版本），WIFI6，免拆刷机，512 兆内存，闲鱼购买价格在 100 左右是超值的价格。闲鱼购买时可以选择让卖家刷好 openwrt 后发出，便可以直接跳转到安装教程。 其他的路由器在确定内存满足要求后，便可以去恩山无线论坛查看是否有 openwrt 的刷机包，以及刷机是否方便。 如果你有自己的小型服务器，而且这个服务器还有两个 wan 口，那么你可以在服务器装虚拟机，然后随便外接一个路由实现无线功能。 2. 安装 UA3F2.1 使用 SSH 工具连接到设备 确保此时你只有一台设备连接到路由器，以免触发校园网的封禁。 2.2 更新软件包以及安装依赖在控制台输入以下指令 opkg updateopkg install curl libcurl luci-compat 2.3 安装 UA3F输入以下指令安装 UA3F，当出现 Install UA3F success说明安装完成 export url=https://blog.sunbk201.site/cdn sh -c $(curl -kfsSl $url/install.sh)service ua3f reload 此时就可以在 openwrt 侧边栏的服务 - UA3F中找到 luci 界面进行管理 3. shellclash 的安装3.1 安装稳定版 shellclash相比于 openclash，这里更推荐 shellclash，因为占用小，性能较好。 同样在控制台输入以下指令 export url=https://fastly.jsdelivr.net/gh/juewuy/ShellCrash@master wget -q --no-check-certificate -O /tmp/install.sh $url/install.sh sh /tmp/install.sh source /etc/profile /dev/null 请选择 稳定版 以及 在/etc目录下安装 3.2 导入修改后的配置文件此时你需要修改 UA3F 作者提供的配置文件 UA3F 增强版配置文件 修改完配置文件后，可以将文件上传到我的网盘获取直链，同时我的网盘也支持在线编辑 上杉九月的网盘 注册完成后点击网站右下角的加号选择文件上传，上传后双击文件进行在线编辑，最后右键文件获取外链 在 shellclash 的控制台，选择 导入配置文件 - 在线获取完整配置文件 3.3 安装本地面板安装本地面板方便管理配置 3.4 关闭只代理常用端口最后一定要关闭 只代理常用端口 3.5 访问管理界面此时点击 CN 策略组的测速按钮，测得 ua3f 是可以连通的，说明配置是正确的。 然后多连几个设备，打开腾讯系应用，在管理界面的连接页面看一下是否触发了规则，走的是机场代理。 三、注意事项目前我在使用的时候，发现 bilibili 手机端默认使用 http 协议播放视频，这会导致看 bilibili 的视频走代理，请在手机端的设置-播放设置-其他播放设置中开始使用 https 播放。 如果有其他问题欢迎在评论区交流反馈，感谢！ 后记前几天看科技宅小明测北京高校的网速，才感觉那句老话说的好，一流大学抓学术、二流大学抓技术、三流大学抓纪律。校园网全覆盖自然是好的，比如说在新的图书馆，有 WIFI 看课啥的都很爽。但是宿舍这地方还搞一堆限制，完全就是搞人心态。现在山东宽带费用不贵吧，千兆宽带一年也就 300 左右，校园网在宿舍可真赚了不少钱。之前和校园网代理还在微信聊过，还说自己也难，没人办理，成本收不回来。哥们你猜为啥没人办，又贵又垃圾，能用流量就流量，能开热点开热点，自然不会加办你这烂的稀碎的校园网。","tags":["UA3F","校园网","Clash","Openwrt"],"categories":["零基础教程"]},{"title":"使用第三方 Cron 定时执行 Github Action","path":"/posts/cron-github-action/","content":"为什么不使用 Github Action 自带的 schedule Github 官方对与 schedule 的定义 Scheduled events（预定事件） The Schedule event allows you to trigger a workflow at a scheduled time.（该Schedule事件允许您在预定时间触发工作流。）Note: The Schedule event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. To decrease the chance of delay, schedule your workflow to run at a different time of the hour. 注意：Schedule在 GitHub 操作工作流运行的高负载期间，事件可能会延迟。高负载时间包括每小时开始。为了减少延迟的可能性，请安排您的工作流在不同的时间运行。 从官方的定义可以看出，schedule 是到了设置的时间把你的任务加入一个待执行队列，如果这时队列出现了拥堵的情况，最糟糕的可能是超过定时时间 1-2 小时还没有执行。也就是说对于执行时间比较敏感的任务，建议使用第三方 cron 平台。 如何使用 cron-job 实现精确的定时任务repository_dispatch 是 GitHub Actions 中的一个事件类型，它允许您通过使用 GitHub API 手动触发存储库中的工作流程运行。所以我们可以使用 cron-job 定时调用 Github 的 API，实现精准的定时执行。 1. 更改action文件的触发条件 添加repository_dispatch on: workflow_dispatch: repository_dispatch: types: [schedule-run] 2. 获取 Personal access tokens在个人 Github 的 SettingsDeveloper Settings 创建 token 选择创建经典的 token 选择 token 权限为 repo 此时就获得了你的 token，保存好。 3. 配置 cron-jobcron-job 官网 注册完成后进入控制台，可以在右上角设置中文 需要填写改为下图内容，需要定时执行哪一个工作流就把对应内容粘贴到网址中 https://api.github.com/repos/需要填写/dispatches 然后在进阶选项中添加标头和请求内容 标头键为 Authorization 值为 token 刚才获取的token 请求体为 ref: main 此时保存后进行测试，显示 204 即为成功，此时你对应的 Github Action 便就执行成功了","tags":["cron","Github"],"categories":["实用工具"]},{"title":"Java的集合框架","path":"/posts/Java_Collection/","content":"集合框架基本概念Collection 集合框架中用于存储一个个元素的容器，List 和 Set 是它的子类 List: 存储有序的，可重复的数据 ArrayList（主要实现类）、LinkedList、Vector Set: 存储无序的，不可重复的数据 HashSet（主要实现类）、LinkedHashSet、TreeSet Map 集合框架中用于存储 key 到 value 的键值映射的容器 Map：存储一对一对的数据 HashMap（主要实现类）、LinkedHashMap、TreeMap、Hashtable、Properties Collections 用于操作集合框架的一个工具类 Collection 常用方法 定义两个集合 Collection collection = new ArrayList();Collection collection1 = new ArrayList();collection.add(test);collection.add(测试);Person person = new Person(10, xiaohua);collection.add(person);collection1.addAll(collection);collection1.add(123); add、addAll 前者用于添加对象元素，后者用于添加一整个集合比较常见 System.out.println(collection);System.out.println(collection1); clear、isEmpty、size 清除集合内的元素，用于查看集合是否为空，查看集合元素数量 collection1.clear();System.out.println(collection1.isEmpty());System.out.println(collection1.size()); contains、containsAll 前者是判断集合中是否含有某个对象，后者是判断一个集合是否包含另一个集合 // 没有重写 equals 方法 对于对象的比较相当于 ==// 注意，String 已经默认重写了 equalsSystem.out.println(collection);System.out.println(collection1);System.out.println(collection.contains(person)); // trueSystem.out.println(collection.contains(new Person(10, xiaohua)));// falseSystem.out.println(collection.contains(test)); // true// 集合之间的包含关系System.out.println(collection.containsAll(collection1)); // falseSystem.out.println(collection1.containsAll(collection)); // true remove、removeAll、retainAll 删除指定元素，删除两个集合的交集，只保留两个集合的交集 System.out.println(collection);System.out.println(collection1);collection1.removeAll(collection);System.out.println(collection1);System.out.println(******************);collection1.add(test);collection1.add(1234);System.out.println(collection);System.out.println(collection1);collection1.retainAll(collection);System.out.println(collection1); toArray asList 把集合转换成数组 @Testpublic void test4() Collection collection = new ArrayList(); collection.add(test); collection.add(测试); collection.add(new Person(10, xiaohua)); // 其他方法 Object[] arr = collection.toArray(); System.out.println(Arrays.toString(arr)); System.out.println(arr[0]); System.out.println(arr[1]); Arrays中的asList 可以将数组转换成集合 public void test6() String[] strings = new String[]a, b, c; Collection collection = Arrays.asList(strings); System.out.println(collection); Iterator 迭代器 迭代器是用来遍历元素的 next、hasNext 获取集合中下一个元素，hasNext 能够判断是否有下一个元素 next 两个作用，第一个是指针下移，第二个是获取当前的元素 @Testpublic void test1() Collection collection = new ArrayList(); collection.add(test); collection.add(测试); Person person = new Person(10, xiaohua); collection.add(person); // 获取迭代器对象 System.out.println(collection); Iterator iterator = collection.iterator();// for (int i = 0; i collection.size(); i++) // System.out.println(iterator.next());// // hasNext while (iterator.hasNext()) System.out.println(iterator.next()); 对于遍历元素还有一种方式，就是增强的 for 循环 使用增强 for 循环的时候，修改 for 循环中的临时变量，将不会修改原有的数据。因为增强 for 循环是将原有的数据赋值给临时变量。 // 增强 for 循环for (Object obj : collection) System.out.println(obj); List 常用方法和 Collection 相同，大体上的方法作用是相同的。这里仅介绍 List 作为有序的集合，相比于 Collection 的不同。 List 不同类的区别 ArrayList：List 主要实现类，线程不安全，效率高，底层使用 Object[] 数组储存 LinkedList：底层使用双向链表的方式进行储存，适用于频繁插入删除的操作 Vector：List 的古老实现类，线程安全，效率低，底层使用 Object[] 数组储存 List 的特殊方法 add(index, element) add 方法相对于 Collection 多了索引，所以可以在指定位置插入元素。同样，addAll也有这样的特性。 @Testpublic void test1() List list = new ArrayList(); list.add(test); list.add(123); Person person = new Person(10, xiaohu); list.add(person); System.out.println(list); // add 插入指定索引的元素 list.add(2, 321); System.out.println(list); // addAll 插入指定索引的集合 List list1 = new ArrayList(); list1.add(test); list1.add(test); list1.add(test); list1.addAll(1, list); System.out.println(list1); remove(index) remove 方法删除的是索引位置的元素，如果要删除数据，用Integer的 valueof 赋值成一个对象即可 // remove 元素删除的指定索引的元素list1.remove(0);list1.remove(0);System.out.println(list1);// 使用Integer创建对象来删除指定元素list1.remove(Integer.valueOf(123));System.out.println(list1); set，get方法 因为 List 有序，所以说对于某一个位置的元素获取变的更加容易 // get，set 方法list.set(0, person);System.out.println(list.get(0)); indexOf，lastIndexOf，subList 第一个是获取指定元素的首次出现的位置，第二个是获取指定元素的最后出现的位置，subList 是获取从 start 到 end 的所有元素 @Testpublic void test2() List list = new ArrayList(); for (int i = 0; i 10; i ++) list.add(i); list.add(i+1); System.out.println(list); System.out.println(list.indexOf(1)); System.out.println(list.lastIndexOf(1)); System.out.println(list.subList(0, 10)); List 综合测试综合测试一 public class StudentTest public static void main(String[] args) List student = new ArrayList(); Scanner scanner = new Scanner(System.in); int flag = 1; while (flag == 1) System.out.println(请输入学生的姓名：); String name = scanner.next(); System.out.println(请输入学生的年龄：); int age = scanner.nextInt(); student.add(new Student(name, age)); System.out.println(输入 1 继续录入，输入 0 停止录入); flag = scanner.nextInt(); for (Object obj : student) Student stu = (Student) obj; System.out.println(stu.toString()); scanner.close(); 综合测试二 对于这个题，list 中存的是 char 字符类型，有两种解决方法。 第一种，存入 list 中的时候在后边加一个 list.add((char)number + ); 第二种，在比较的时候对 char 使用 String 的 valueOf 方法进行赋值 String c = String.valueOf(iterator.next());String c = String.valueOf(obj); 完整代码 public class StringTest public static void main(String[] args) ArrayList list = new ArrayList(); for (int i = 0; i 30; i++) int max = 122 - 97 + 1; int number = (int) (Math.random() * max + 97); list.add((char)number + ); System.out.println(list); int aCount = listTest1(list, a); int bCount = listTest1(list, b); int cCount = listTest1(list, c); int xCount = listTest1(list, x); System.out.printf(%d %d %d %d , aCount, bCount, cCount, xCount); // 迭代器 public static int listTest2(Collection list, String s) int count = 0; Iterator iterator = list.iterator(); while (iterator.hasNext()) String c = String.valueOf(iterator.next()); if(c.equals(s)) count++; return count; // 增强 for 循环 public static int listTest1(Collection list, String s) int count = 0; for (Object obj : list) String c = String.valueOf(obj); if (c.equals(s)) count++; return count; Set 常用方法Set 声明的方法与 Collection 中声明的 15 个抽象方法相同 对于 Set 来说，我们更重要的是研究他的两个特性。 Set 的常见实现类 HashSet：主要实现类，底层使用 HashMap，也就是使用了数组，单向链表，红黑树结构进行存储 LinkedSet：HashSet 的子类，相比与父类，它在不同的元素之间增加了指针，实现了顺序遍历 TreeSet：底层使用红黑树存储， 可以根据添加的元素对指定的属性大小进行遍历。 Set 的无序性这里的无序性并不是随机性，对与 Set 来说，它保存是数据的方法是 HashMap，也就是对于将要保存的元素，计算它的哈希值，哈希值即为这个元素的保存位置，所以当添加完元素后，你输入的数据将不会按照顺序保存，而是根据自己的计算结果保存到不同位置，这就是 Set 的无序性。 按照 1- 5 的顺序进行输入，经过哈希算法计算后排列的位置如下图所示 LinkedSet 相当于增加了一个指针，让 1 指向 2，2 指向 3，以此类推，最后遍历的时候便可以根据指针进行遍历。 Set 的不可重复性比较的标准是首先判断 HashCode 得到的哈希值是否相同，如果相等则进行 euqals。只有两者都相同，则认为元素是相同的。 演示代码 HashSet这里可能会有疑问，不是说 Set 中不存在重复的元素，难道对自定义的实体类不生效吗。 我们从Set 存入数据的过程看到，Set 首先要对元素进行哈希计算，这里我们 new 的两个 Person 对象，他们的实体类中没有重写 HashCode 方法，因此调用的是 Object 的方法，该方法并不会把这两个赋值相同的对象计算得到相同的哈希值，所以 Set 会把两个元素看做不同的元素。 为了避免这种问题，我们需要重写实体类中的 HashCode。 测试代码 @Testpublic void test2() Set set = new HashSet(); set.add(test); set.add(123); set.add(new Person(10,xiaohua)); set.add(new Person(10,xiaohua)); System.out.println(set); 重写 HashCode @Overridepublic int hashCode() int result = age; result = 31 * result + (name != null ? name.hashCode() : 0); return result; 此时的运行结果 演示代码 LinkedSetLinkedSet 的优势就是能按照输入顺序输出 @Testpublic void test1() // LinkedHashSet 实现了记录添加元素的顺序，方便进行遍历 Set set = new LinkedHashSet(); Person person = new Person(10,xiaohua); set.add(test); set.add(123); set.add(person); System.out.println(set); Iterator iterator = set.iterator(); while (iterator.hasNext()) System.out.println(iterator.next()); 演示代码 TreeSet对于 TreeSet 来说，最主要的用处是对插入元素的排序。例如对字符串进行排序 @Testpublic void test3() Set set = new TreeSet(); set.add(BB); set.add(AA); set.add(GG); set.add(ZZ); set.add(YY); // 同一个 TreeSet 中不能添加不同类型的元素，以下添加 123 就会出错 set.add(123); System.out.println(set); 运行结果 对于 TreeSet 添加自定义的实体类，进行排序的时候如何进行的判断，实际上是使用了自然排序和自定义排序，compareTo 和 compare 的返回值 以下代码中我重写了 User 中 compareTo 的方法，使得元素按照年龄排序，由于 TreeSet 采用的是红黑树的数据结构，存入的数据不能重复，所以说在按照年龄进行排序的时候，还需要别的元素进行辅助排序。 @Testpublic void test4() Set set = new TreeSet(); Person p1 = new Person(10,xiaohua); Person p2 = new Person(12,xiaohua1); Person p3 = new Person(12,xiaohua2); Person p4 = new Person(13,xiaohua3); Person p5 = new Person(14,xiaohua4); set.add(p1); set.add(p2); set.add(p3); set.add(p4); set.add(p5); for (Object o : set) System.out.println(o); 重写的 compareTo 方法 @Overridepublic int compareTo(Object o) if (this == o) return 0; if (o instanceof Person) Person p = (Person) o; int number = this.age - p.age; if (number != 0) return number; else return this.name.compareTo(p.name); throw new RuntimeException(类型不匹配); 输出结果 对于不方便修改实体类中的比较方法的情况，可以直接给 TreeSet 一个 Comparator 方法 @Testpublic void test4() Comparator comparator = new Comparator() @Override public int compare(Object o1, Object o2) if (o1 instanceof Person o2 instanceof Person) Person p1 = (Person) o1; Person p2 = (Person) o2; int value = p1.getName().compareTo(p2.getName()); if (value != 0) return value; else return p1.getAge() - p2.getAge(); throw new RuntimeException(数据类型不匹配); ; Set set = new TreeSet(comparator); Person p1 = new Person(10,A1); Person p2 = new Person(13,A1); Person p3 = new Person(10,B); Person p4 = new Person(13,C); Person p5 = new Person(13,D); set.add(p1); set.add(p2); set.add(p3); set.add(p4); set.add(p5); for (Object o : set) System.out.println(o); Set 综合测试综合测试一 @Testpublic void test5() List list = new ArrayList(); list.add(11); list.add(11); list.add(11); list.add(11); list.add(22); list.add(22); list.add(22); list.add(22); list.add(33); list.add(33); list.add(33); list.add(33); System.out.println(list); System.out.println(duplicateList(list));public static List duplicateList(List list) Set set = new LinkedHashSet(list); List new_list = new ArrayList(set); return new_list; 综合测试二 @Testpublic void test7() Set set = new HashSet(); while (set.size() 10) int randomNumber = (int)(Math.random() * 20) + 1; set.add(randomNumber); System.out.println(set); Map 常用方法Map 不同类的区别 java.util.Map: 存储一对一对的数据，也就是 key-value 键值对 HashMap: 主要实现类，线程不安全的，效率高的。可以添加 null 的 key 与 value。底层使用数组，单向链表，红黑树的数据结构。 LinkedMap：HashMap 的子类，添加了一对双向链表，记录添加的元素的先后顺序。 TreeMap: 底层使用红黑树的数据结构，可以根据添加的 key 元素指定的属性大小进行遍历。 Hashtable: 古老实现类，线程安全的，效率低的。不可以添加 null 的 key 和 value。底层使用数组，单向链表的数据结构。 Properties: 演示代码 HashMap在 HashMap 中，key 是不能够相同的，并且是无序的。而 value 是可以相同的，但由于 value 是 key 的映射，key 是无序的，value 也是无序的。 HashMap 中所有的 key 构成了一个 Set 集合，key 所在的类，需要重写 equals 和 HashCode 方法。 HashMap 中所有的 value 构成了一个Collection 集合，value 所在的类，需要重写 equals 方法。 增删改查 put、putAll、remove、put、get @Testpublic void test() // 增 Map map = new HashMap(); Person p1 = new Person(10,xiaoming); map.put(AA, 123); map.put(BB, 13); map.put(CC, 23); map.put(p1, 55); System.out.println(map); Map map1 = new HashMap(); map1.putAll(map); System.out.println(map1); @Testpublic void test2() // 删 改 查 Map map = new HashMap(); Person p1 = new Person(10,xiaoming); map.put(AA, 123); map.put(BB, 13); map.put(CC, 23); map.put(p1, 55); Object value = map.remove(BB); System.out.println(value); map.put(CC, 15); // value System.out.println(map.get(CC)); System.out.println(map); 长度 遍历 size、keySet、values、entrySet @Testpublic void test3() Map map = new HashMap(); Person p1 = new Person(10, xiaoming); map.put(AA, 123); map.put(BB, 13); map.put(CC, 23); map.put(p1, 55); System.out.println(map.size()); // keySet 遍历 key Set keySet = map.keySet(); for (Object o :keySet) System.out.println(o); // values 遍历 value Collection values = map.values(); for (Object o : values) System.out.println(o); // entrySet 遍历 entry 键值对 Set entrySet = map.entrySet(); for (Object o :entrySet) System.out.println(o); 演示代码 TreeMap对于 TreeMap 来说，和 TreeSet 一样，重要的是自然排序和定制排序的写法。 自然排序，根据实体类中的 compareTo 方法 @Testpublic void test2() // 自然排序 Map map = new TreeMap(); Person p1 = new Person(10, zeus); Person p2 = new Person(14, faker); Person p3 = new Person(12, jerry); Person p4 = new Person(12, tom); map.put(p1, 12); map.put(p2, 63); map.put(p3, 42); map.put(p4, 31); Set entry = map.entrySet(); for (Object o : entry) System.out.println(o); 定制排序，TreeMap 同样可以传入一个 comparator，在这里 comparator 中我们可以自定义按照类的什么属性进行排序 @Testpublic void test1() Comparator comparator = new Comparator() @Override public int compare(Object o1, Object o2) if (o1 instanceof Person o2 instanceof Person) Person p1 = (Person) o1; Person p2 = (Person) o2; int value = p1.getName().compareTo(p2.getName()); if (value != 0) return value; else return p1.getAge() - p2.getAge(); throw new RuntimeException(数据类型不匹配); ; Map map = new TreeMap(comparator); Person p1 = new Person(10, zeus); Person p2 = new Person(14, faker); Person p3 = new Person(12, jerry); Person p4 = new Person(12, tom); map.put(p1, 12); map.put(p2, 63); map.put(p3, 42); map.put(p4, 31); Set entry = map.entrySet(); for (Object o : entry) System.out.println(o); 演示代码 PropertiesProperties 多用于在文件的 IO 流中，使用 Properties 读取配置文件可以有效的提高代码的可维护性。 @Testpublic void test1() throws IOException File file = new File(config.properties); System.out.println(file.getAbsolutePath()); FileInputStream fileInputStream = new FileInputStream(file); Properties properties = new Properties(); properties.load(fileInputStream); System.out.println(properties.get(name)); System.out.println(properties.get(password)); fileInputStream.close(); Collections 工具类排序操作// 排序操作@Testpublic void test1() List list = Arrays.asList(1,42,32,43,45,3,4,53,23,31,45,98); System.out.println(list); // reverse 反转 list 中元素的顺序 Collections.reverse(list); System.out.println(list); // shuffle 对 list 中的元素进行随机排序 Collections.shuffle(list); System.out.println(list); // sort 对 list 中的元素进行自然排序 Collections.sort(list); System.out.println(list); Comparator comparator = new Comparator() @Override public int compare(Object o1, Object o2) if (o1 instanceof Integer o2 instanceof Integer) Integer i1 = (Integer) o1; Integer i2 = (Integer) o2; return -(i1.intValue() - i2.intValue()); throw new RuntimeException(类型不匹配); ; // sort 对 list 中的元素进行定制排序 Collections.sort(list, comparator); System.out.println(list); 查找操作// 查找操作@Testpublic void test2() List list = Arrays.asList(1, 42, 1, 43, 45, 1, 4, 53, 23, 31, 45, 98); System.out.println(list); // max 获取 list 中的最大值 Object max = Collections.max(list); System.out.println(max); Comparator comparator = new Comparator() @Override public int compare(Object o1, Object o2) if (o1 instanceof Integer o2 instanceof Integer) Integer i1 = (Integer) o1; Integer i2 = (Integer) o2; return -(i1.intValue() - i2.intValue()); throw new RuntimeException(类型不匹配); ; // max 同样可以接受一个 comparator，因为它获取的逻辑是排序后的最右边的数据，如果 comparator 传入的是倒序，最大值反而是最小值 Object max1 = Collections.max(list, comparator); System.out.println(max1); // frequency 返回 list 中指定元素出现的个数 int number = Collections.frequency(list, 1); System.out.println(number); 复制，替换操作@Testpublic void test3() List list = Arrays.asList(1, 42, 1, 43, 45, 1, 4, 53, 23, 31, 45, 98); System.out.println(list); // copy 将一个 list 赋值到一个新的 list，但是新的 list 的 size 必须大于等于旧的 list List new_list = Arrays.asList(new Object[list.size()]); Collections.copy(new_list, list); System.out.println(new_list); unmodifiableList 生成一个只读格式的 list @Testpublic void test4() List list = Arrays.asList(1, 42, 1, 43, 45, 1, 4, 53, 23, 31, 45, 98); System.out.println(list); List new_list = Collections.unmodifiableList(list); // unmodifiableList 将 list 转换成一个新的只读的 list new_list.add(12);","tags":["Java","学习笔记","集合框架"],"categories":["学习笔记"]},{"title":"算法通关村第一关-链表白银挑战笔记","path":"/posts/Yupi-01-Second/","content":"题目练习JZ52 两个链表的第一个公共结点描述输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） 数据范围： $n \\leq 1000$ 要求：$O(1)$，时间复杂度 $O(1)$ 例如，输入{1,2,3},{4,5},{6,7}时，两个无环的单向链表的结构如下图所示： 可以看到它们的第一个公共结点的结点值为6，所以返回结点值为6的结点。 输入描述输入分为是3段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和第二个链表的公共部分。 后台会将这3个参数组装为两个链表，并将这两个链表对应的头节点传入到函数FindFirstCommonNode里面，用户得到的输入只有pHead1和pHead2。 返回值描述返回传入的pHead1和pHead2的第一个公共结点，后台会打印以该节点为头节点的链表。 样例输入: 1,2,3,4,5,6,7输出: 6,7输入: 1,2,3,输出: 欢迎关注我的其他平台","tags":["Java","学习笔记","鱼皮的算法通关村"],"categories":["学习笔记"]},{"title":"算法通关村第一关-链表青铜挑战笔记","path":"/posts/Yupi-01-First/","content":"重要说明 图片与实际代码无关，这里引用的图片有很大一部分是把头结点当做链表的第一个元素，我写的示例代码不将头结点视为第一个元素 链表的概念简单来说就是说从头结点出发，每一个结点都有一个指向后继结点的 next 指针，表中最后一个元素的 next 指向 null 链表的构造结构这里我们使用 Java 来创建单链表的基本结构，这里是 Leetcode 常用的构建方法 public class ListNode public int val; public ListNode next; ListNode(int x) val = x; next = null; ListNode node = new ListNode(1); 对于简化的构造方法，你应该使用以下的代码对结点进行修改赋值 node.next = new_node;node.val = number; 为了练习 Java 的面向对象特性，这里我不用简化的构造方法。 public class ListNode // 链表数据 private int data; // 链表指针 private ListNode next; public ListNode(int data) this.data = data; public int getData() return data; public void setData(int data) this.data = data; public ListNode getNext() return next; public void setNext(ListNode next) this.next = next; 而这种方式的修改赋值就是调用 get 和 set 办法 node.setNext(new_node);node.setNext(new_node.getNext());node.setData(number);node.getData(); 链表的增删改查 - 增任何数据结构都避免不了的最基础的操作，首先来看最基础的构建链表。 对于单链表来说，构建链表有两种方式，一种是头插法，一种是尾插法。 头插法头插法简单说来就是逆序插入，每次插入将新节点的 next 指向头结点的 next，然后将头结点的 next 指向新结点。 示例代码 // 头插法插入新结点public ListNode headInsert(ListNode head, ListNode node) node.setNext(head.getNext()); head.setNext(node); return head; 尾插法尾插法简单来说就是顺序插入，每次插入都将此时的“头结点”的 next 改成新结点 node，然后将新结点 node 座位链表尾部，next 改为 null。和头插法不一样的是，尾插法每次返回的结点并不是头结点，所以在构建链表的时候记得保存头结点的信息。 // 尾插法插入新结点public ListNode tailInsert(ListNode head, ListNode node) head.setNext(node); node.setNext(null); return node; 构建链表这段代码展示了在测试类中初始化链表的全过程，这里我用 L 结点保存尾插时头结点的信息，后续会用到。 public static void main(String[] args) ListNodeTest test = new ListNodeTest(); // 初始化头结点 ListNode head = new ListNode(-1); head.setNext(null); // 复制头结点 ListNode L = head; // 构建链表 test.initList(head, 5); // 构建新链表 public ListNode initList(ListNode head, int number) for (int i = 0; i number; i++) ListNode new_node = new ListNode(i); // 头插法 head = headInsert(head, new_node); // 尾插法 head = tailInsert(head, new_node); return head; 综合练习// 具体位置插入结点public ListNode insertNode(ListNode head, ListNode node, int position) // 头结点为空，意味着链表为空，故此时返回要插入的结点 if (head == null) return node; // 检查插入的位置是否越界, 返回头结点等待下次插入 int length = getListLength(head); if (position length + 2 || position 1) System.out.println(位置参数越界); return head; // 遍历找到前驱节点，使用头插法插入新结点 ListNode P = head; for (int i = 0 ; i position; i++) P = P.getNext(); headInsert(P, node); return head; 运行结果 链表的增删改查 - 查先来看看链表的查询，对于单链表来说，一定是从头结点逐个向后访问，因此，头结点是一定不可以丢掉的。 我们写一个遍历函数，同时输出链表长度 // 获取链表长度public int getListLength(ListNode head) int length = 0; ListNode node = head; while(node != null) length++; System.out.printf(%d , node.getData()); node = node.getNext(); return length; 这里可以看出，传入遍历函数的结点不同，因为头插法返回的都是头结点，此时的 head 可以说是没变，直接传入。而对于尾插法来说，我这里的处理是用了一个 L 结点存储头结点信息，所以传入遍历函数的是 L 结点。 // 头插法获取链表可以直接传入返回的 head，因为头插法每次返回的都是头结点// 尾插法获取链表需要传入之前复制的头结点信息，因为尾插法每次返回的是结点System.out.println(链表长度为: + (test.getListLength(head) - 1));System.out.println(链表长度为: + (test.getListLength(L) - 1)); 链表的增删改查 - 删对于删除来说还是挺好办的，处理以下特殊位置，其他位置遍历到前驱结点，然后将前驱结点的 next 直接设置为删除结点的后置结点。 表头这种情况只需要 head = head.getNext(); 表尾和其他遍历到删除结点的前驱就可以进行操作了 // 删除目标结点public ListNode deleteNode(ListNode head, int position) // 头结点为空，意味着链表为空，无法删除 if (head == null) return null; // 检查插入的位置是否越界, 返回头结点等待下次插入 int length = getListLength(head); if (position length + 1 || position 1) System.out.println(位置参数越界); return head; // 表头元素删除 if (position == 1) head.setNext(head.getNext().getNext()); // 表尾和其他位置 ListNode P = head; for (int i = 0; i position - 1; i++) P = P.getNext(); P.setNext(P.getNext().getNext()); return head; 运行结果 链表的增删改查 - 改改也是水到渠成，同样的操作，只不过这次直接遍历到需要修改的结点即可 // 修改目标结点public ListNode changeNode(ListNode head, int data, int position) // 头结点为空，意味着链表为空，无法删除 if (head == null) return null; // 检查插入的位置是否越界, 返回头结点等待下次插入 int length = getListLength(head); if (position length + 1 || position 1) System.out.println(位置参数越界); return head; // 遍历后修改 ListNode P = head; for (int i = 0; i position; i++) P = P.getNext(); P.setData(data); return head; 运行结果","tags":["Java","学习笔记","鱼皮的算法通关村"],"categories":["学习笔记"]},{"title":"Java的面向对象","path":"/posts/Java_OOP/","content":"多态多态的基本使用实体类package Person;/** * @author sakurasep * * @date 2024/3/13 **/public class Person String name; int age; public void eat() System.out.println(人吃饭); public void walk() System.out.println(人走路); package Person;/** * @author sakurasep * * @date 2024/3/13 **/public class Man extends Person boolean isSomking; public void eat() System.out.println(男人吃肉); public void walk() System.out.println(男人走路); public void play() System.out.println(男人打游戏); package Person;/** * @author sakurasep * * @date 2024/3/13 **/public class Woman extends Person boolean isBeauty; public void eat() System.out.println(女人吃甜点); public void walk() System.out.println(女人走路); public void watch() System.out.println(女人看剧); package Person;/** * @author sakurasep * * @date 2024/3/13 **/public class PersonTest public static void main(String[] args) Person person = new Person(); person.eat(); person.walk(); Man man = new Man(); man.eat(); man.walk(); Woman woman = new Woman(); woman.eat(); woman.walk(); System.out.println(*********多态性********); Person person1 = new Man(); person1.eat(); person1.walk(); Person person2 = new Woman(); person2.eat(); person2.walk(); 测试方法package Person;/** * @author sakurasep * * @date 2024/3/13 **/public class PersonTest public static void main(String[] args) Person person = new Person(); person.eat(); person.walk(); Man man = new Man(); man.eat(); man.walk(); Woman woman = new Woman(); woman.eat(); woman.walk(); System.out.println(*********多态性********); Person person1 = new Man(); person1.eat(); person1.walk(); Person person2 = new Woman(); person2.eat(); person2.walk(); 输出结果 多态的实际使用测试方法 源码 当不存在多态性的时候 package Person;/** * @author sakurasep * * @date 2024/3/13 **/public class AccountTest public static void main(String[] args) AccountTest test = new AccountTest(); test.console(new Account()); System.out.println(-------------); test.console(new CheckAccount()); System.out.println(-------------); test.console(new SaveAccount()); public void console(Account account) account.saveMoney(100); account.getMoney(40); public void console(CheckAccount account) account.saveMoney(100); account.getMoney(40); public void console(SaveAccount account) account.saveMoney(100); account.getMoney(40); class Account String username; String password; int money; // 余额 // 存钱 public void saveMoney(int money) this.money = money; System.out.printf(普通账户余额为: %d , this.money); // 取钱 public void getMoney(int money) if(money = this.money) this.money -= money; System.out.printf(普通账户余额为: %d , this.money); else System.out.println(普通账户余额不足); class CheckAccount extends Account int quota = 500; // 额度 public void saveMoney(int money) this.money = money + quota; System.out.printf(信用卡账户余额为: %d , this.money); // 取钱 public void getMoney(int money) if(this.money = money) this.money -= money; System.out.printf(信用卡余额为: %d , this.money); else System.out.println(信用卡余额不足); class SaveAccount extends Account float money; float rate = 0.2F; // 利率 float interest; // 利息 public void saveMoney(int money) interest = money * rate; this.money = money + interest; System.out.printf(储蓄卡预期余额为: %f , this.money); public void getMoney(int money) if(this.money - interest money) this.money -= money; System.out.printf(储蓄卡余额为: %f , this.money); else System.out.println(储蓄卡余额不足); 正常情况下，如果没有 Java 的多态性，那么对于不同对象的方法调用，就需要如下这样写多个同名方法，赋予不同对象的形参 public void console(Account account) account.saveMoney(100); account.getMoney(40);public void console(CheckAccount account) account.saveMoney(100); account.getMoney(40);public void console(SaveAccount account) account.saveMoney(100); account.getMoney(40); 而因为 Java 的多态性，这里的方法便可以省略重复调用，在实际的项目中，多态很有用，符合开闭原则。对于增加新的子类，方法都不需要进行改变，只定义一个父类即可。 public void console(Account account) account.saveMoney(100); account.getMoney(40); 输出结果 Java 向下转型测试方法虽然创建的子类的对象，也加载了子类的特有的方法和属性，但是因为我们声明的是父类的引用，所以没有办法直接调用子类特有的属性和方法。 注意，在向下转型的时候可能会出现类型转换异常，即你要转换的类型并不是你声明的类型 所以在进行向下转型之前，为了程序的健壮性，最好使用 instanceof 进行判断 public class AccountTest public static void main(String[] args) AccountTest test = new AccountTest(); test.console(new CheckAccount()); test.console(new SaveAccount()); public void console(Account account) account.saveMoney(100); account.getMoney(40); // 避免出现类型转换异常 if (account instanceof CheckAccount) CheckAccount check_account = (CheckAccount)account; check_account.getQuota(); if (account instanceof SaveAccount) SaveAccount save_account = (SaveAccount)account; save_account.getInterest(); save_account.getRate(); 输出结果 多态案例练习题目 关系图 实体类package Geometric;/** * @author sakurasep * * @date 2024/3/19 **/public class GeometricObject protected String color; protected double weight; protected GeometricObject(String color, double weight) this.color = color; this.weight = weight; public String getColor() return color; public void setColor(String color) this.color = color; public double getWeight() return weight; public void setWeight(double weight) this.weight = weight; public double findArea() return 0; package Geometric;/** * @author sakurasep * * @date 2024/3/19 **/public class Circle extends GeometricObject private double radius; public Circle(String color, double weight, double radius) super(color, weight); this.radius = radius; public double getRadius() return radius; public void setRadius(double radius) this.radius = radius; @Override public double findArea() return 3.14 * radius * radius; package Geometric;/** * @author sakurasep * * @date 2024/3/19 **/public class MyRectangle extends GeometricObject private double width; private double height; public MyRectangle(String color, double weight, double width, double height) super(color, weight); this.width = width; this.height = height; public double getWidth() return width; public void setWidth(double width) this.width = width; public double getHeight() return height; public void setHeight(double height) this.height = height; @Override public double findArea() return width * height; 测试方法package Geometric;import Person.Man;/** * @author sakurasep * * @date 2024/3/19 **/public class GeometricTest public static void main(String[] args) GeometricTest test = new GeometricTest(); Circle c1 = new Circle(red, 1.0, 4); Circle c2 = new Circle(bule, 1.0, 4); MyRectangle m1 = new MyRectangle(red, 1.0, 4, 4); test.displayGeometricObject(c1); test.displayGeometricObject(c2); test.displayGeometricObject(m1); boolean isEquals = test.equalsArea(c1, c2); if (isEquals) System.out.println(面积相等); else System.out.println(面积不等); public boolean equalsArea(GeometricObject object1, GeometricObject object2) return object1.findArea() == object2.findArea(); public void displayGeometricObject(GeometricObject object) System.out.println(几何图形的面积为: + object.findArea()); 输出结果 重写对象方法重写 Object 类的 equals() 方法对于 String，File ，包装类等已经重写了 Object 的 equals 方法。我们自己用的时候，通常也可以重写 equals 方法实现对象的应用。 当然 IDEA 自带重写 equals 方法 实体类class User private int age; private String name; public User() public User(int age, String name) this.age = age; this.name = name; @Override public boolean equals(Object obj) if (this == obj) return true; if (obj instanceof User) User user = (User) obj; return this.age == user.age this.name.equals(user.name); return false; @Override public boolean equals(Object o) if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; if (age != user.age) return false; return Objects.equals(name, user.name); 测试方法public class UserTest public static void main(String[] args) User u1 = new User(10, lihua); User u2 = new User(10, xiaoli); User u3 = new User(10,lihua); System.out.println(u1.equals(u2)); System.out.println(u1.equals(u3)); 输出结果 重写 toString() 方法和 equals 一样，String，File 等也已经预先重写了 toString 方法，对于自定义类，我们同样可以进行重写 @Overridepublic String toString() return Use r + name: + name + age: + age; 当然，IDEA 也可以自动生成对象的 toString 方法 @Overridepublic String toString() return User + age= + age + , name= + name + \\ + ; 关键字 Static","tags":["Java","学习笔记"],"categories":["学习笔记"]},{"title":"SpringBoot学习笔记","path":"/posts/SpringBoot_01/","content":"Spring Boot 入门需求一使用 Spring Boot 开发 Web 应用，浏览器发起hello请求，返回字符串”hello wordld” 步骤 创建 Maven 工程 导入spring-boot-stater-web 起步依赖 编写 Controller 提供启动类 实现创建项目 添加依赖 创建 Controller 包，HelloController 类 package com.sakurasep.springboot.controller;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author sakurasep * * @date 2024/3/12 **/@RestControllerpublic class HelloController @RequestMapping(/hello) public String hello() return hello world; 运行启动类 测试结果 需求二认识配置文件 - application.yml 相比于 properties 更推荐 yml server: port: 9090 servlet: context-path: /start 使用 @Value 注解获取配置文件键名 email:\tuser: sakurasep@qq.com\tauth: true @Value(email.user)public String user;@Value(email.auth)public boolean auth 使用 @ConfigurationProperties 注解获取配置文件 @ConfigurationProperties(prefix = email)public class User public String user; public boolean auth; 需求三使用 Spring 整合 mybatis，实现web 访问 findByid?id1 将从数据库读取 id 为1的数据 编写 application.yml 配置文件 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456 url: jdbc:mysql://localhost:3306/tlias 在 pom.xml 添加 mybatis 和 mysql 驱动依赖（添加完成后使用 Maven 构建一下） dependency groupIdorg.mybatis.spring.boot/groupId artifactIdmybatis-spring-boot-starter/artifactId version3.0.0/version/dependencydependency groupIdcom.mysql/groupId artifactIdmysql-connector-j/artifactId/dependency 在 pojo 层下面创建 User 实体类 pojo层的用途 在Spring Boot项目中，通常会创建一个名为pojo（Plain Old Java Object）的软件包。POJO是指普通的Java对象，它们是没有任何特殊限制的简单Java对象，用于表示应用程序中的数据实体或值对象。这些对象通常只包含私有字段和公共访问器方法，没有特定的框架或库的依赖。 package com.sakurasep.springboot.pojo;/** * @author sakurasep * * @date 2024/3/12 **/public class User private Integer id; private String username; private String password; private String name; public Integer getId() return id; public void setId(Integer id) this.id = id; public String getUsername() return username; public void setUsername(String username) this.username = username; public String getPassword() return password; public void setPassword(String password) this.password = password; public String getName() return name; public void setName(String name) this.name = name; public Integer getGender() return gender; public void setGender(Integer gender) this.gender = gender; private Integer gender; 在 mapper 层下创建 UserMapper 接口，用于 Mybatis 实现对数据库的操作 mapper层的用途 在Spring Boot项目中，mapper包通常用于存放数据访问对象（DAO）的接口或类。这些接口或类通常用于定义与数据持久化相关的操作，如数据库的CRUD（创建、读取、更新、删除）操作。 package com.sakurasep.springboot.mapper;import com.sakurasep.springboot.pojo.User;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;/** * @author sakurasep * * @date 2024/3/12 **/@Mapperpublic interface UserMapper @Select(select * from emp where id = #id) public User findByid(Integer id); 在 service 层 创建 UserService 接口 以及 具体的业务逻辑代码 UserServiceImpl 类 Service层的用途 在Spring Boot项目中，Service层通常是业务逻辑层，用于处理应用程序的业务逻辑。Service层在MVC（模型-视图-控制器）架构中位于控制器层和持久化层之间，它负责处理业务逻辑、协调不同的持久化操作，并提供一组服务供控制器层调用。 impl包的用途 在一个典型的Spring Boot项目中，Service层下通常会有一个名为impl（implementation的缩写）的包，它是Service层的具体实现。这个包中包含了实际执行业务逻辑的类。 package com.sakurasep.springboot.service;import com.sakurasep.springboot.pojo.User;/** * @author sakurasep * * @date 2024/3/12 **/public interface UserService public User findByid(Integer id); package com.sakurasep.springboot.service.impl;import com.sakurasep.springboot.mapper.UserMapper;import com.sakurasep.springboot.pojo.User;import com.sakurasep.springboot.service.UserService;import org.apache.ibatis.annotations.Select;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * @author sakurasep * * @date 2024/3/12 **/@Servicepublic class UserServiceImpl implements UserService @Autowired private UserMapper userMapper; public User findByid(Integer id) return userMapper.findByid(id); 在 Controller 层 编写 UserController 类 Controller层的用途 Controller是Spring Boot项目中的一个组成部分，负责处理客户端请求并将结果返回给客户端。它充当了应用程序的入口点，并与用户交互，通常用于接收HTTP请求、调用Service层处理业务逻辑，并将处理结果返回给客户端。 package com.sakurasep.springboot.controller;import com.sakurasep.springboot.mapper.UserMapper;import com.sakurasep.springboot.pojo.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author sakurasep * * @date 2024/3/12 **/@RestControllerpublic class UserController @Autowired private UserMapper userMapper; @RequestMapping(/findByid) public User findByid(Integer id) return userMapper.findByid(id); 测试结果","tags":["SpringBoot","学习笔记"],"categories":["学习笔记"]},{"title":"SpringBoot后端工程搭建","path":"/posts/Xiaoha_Blog_02/","content":"SpringBoot后端工程搭建搭建 Spring Boot 多模块工程（通过 Spring Initializr）什么是多模块项目多模块项目是项目构建中的概念。拿 Maven 来说，多模块项目（Multi-Module Project）是其一个重要特性，它允许我们在一个项目中管理多个子模块。 在一个 Maven 多模块项目中，每个模块都是一个独立的项目，拥有自己的 POM 文件（Project Object Model，项目对象模型）。这些模块可以互相依赖，也可以被其他项目依赖。但是，所有的模块都会被统一管理，它们共享同一套构建系统和依赖管理。 为什么要使用多模块项目主要有以下几个原因： 代码组织：在大型项目中，我们经常需要把代码分成多个模块，以便更好地组织代码。每个模块可以聚焦于一个特定的功能或领域，这样可以提高代码的可读性和可维护性。 依赖管理：Maven 多模块项目可以帮助我们更好地管理项目的依赖。在父项目的 POM 文件中，我们可以定义所有模块共享的依赖，这样可以避免重复的依赖定义，也方便我们管理和升级依赖。 构建和部署：Maven 多模块项目的另一个优点是它可以统一管理项目的构建和部署。我们只需要在父项目中执行 Maven 命令，就可以对所有模块进行构建和部署。这大大简化了开发者的工作。 IDEA 搭建 Spring Boot 多模块工程骨架构建父项目 - weblog 没有找到JDK8？ 服务器url替换成aliyun，否则无法使用jdk8 项目初始化目录，删除无用的文件 创建 web 访问模块这是项目的入口，maven 打包的打包插件在这里存放，同时，博客的前端相关内容也统一存放在这里。 勾选依赖 Lombok 和 Spring Web 创建后台管理模块该模块负责统一放置和管理后台相关的功能 依赖仅用 Lombok，后续再增加新的模块 创建通用模块该模块存放一些通用的功能，比如接口的日志切面，全局异常管理 pom 文件解析weblog在父项目的 pom.xml 文件中对项目进行统一管理 对项目的版本号进行统一管理 项目版本号，主要是涉及项目自身的开发版本，JDK 版本，项目编码 Maven 相关内容，依赖的是 JDK 版本 项目依赖包的版本号 !-- 版本号统一管理 -- properties !-- 项目版本号 -- revision0.0.1-SNAPSHOT/revision java.version1.8/java.version project.build.sourceEncodingUTF-8/project.build.sourceEncoding !-- Maven 相关 -- maven.compiler.source$java.version/maven.compiler.source maven.compiler.target$java.version/maven.compiler.target !-- 依赖包版本 -- lombok.version1.18.28/lombok.version guava.version31.1-jre/guava.version commons-lang3.version3.12.0/commons-lang3.version jackson.version2.15.2/jackson.version /properties 项目相关依赖的管理 子模块的名称以及版本号 常用依赖工具的名称以及版本号 !-- 统一依赖管理 -- dependencyManagement dependencies dependency groupIdcom.sakurasep/groupId artifactIdweblog-admin/artifactId version$revision/version /dependency dependency groupIdcom.sakurasep/groupId artifactIdweblog-common/artifactId version$revision/version /dependency !-- 常用工具库 -- dependency groupIdcom.google.guava/groupId artifactIdguava/artifactId version$guava.version/version /dependency dependency groupIdorg.apache.commons/groupId artifactIdcommons-lang3/artifactId version$commons-lang3.version/version /dependency !-- Jackson -- dependency groupIdcom.fasterxml.jackson.core/groupId artifactIdjackson-databind/artifactId version$jackson.version/version /dependency /dependencies /dependencyManagement 项目的构建设置 这里添加了spring-boot-maven-plugin build !-- 统一插件管理 -- pluginManagement plugins plugin groupIdorg.springframework.boot/groupId artifactIdspring-boot-maven-plugin/artifactId configuration excludes exclude groupIdorg.projectlombok/groupId artifactIdlombok/artifactId /exclude /excludes /configuration /plugin /plugins /pluginManagement/build weblog-web?xml version=1.0 encoding=UTF-8?project xmlns=http://maven.apache.org/POM/4.0.0 xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion4.0.0/modelVersion !-- 指定父项目为 weblog-springboot -- parent groupIdcom.sakurasep/groupId artifactIdweblog-springboot/artifactId version$revision/version /parent groupIdcom.sakurasep/groupId artifactIdweblog-web/artifactId nameweblog-web/name descriptionweblog-web (入口项目，负责博客前台展示相关功能，打包也放在这个模块负责)/description dependencies dependency groupIdcom.sakurasep/groupId artifactIdweblog-common/artifactId /dependency dependency groupIdcom.sakurasep/groupId artifactIdweblog-admin/artifactId /dependency !-- Web 依赖 -- dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-web/artifactId /dependency !-- 免写冗余的 Java 样板式代码 -- dependency groupIdorg.projectlombok/groupId artifactIdlombok/artifactId optionaltrue/optional /dependency !-- 单元测试 -- dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-test/artifactId scopetest/scope /dependency /dependencies build plugins plugin groupIdorg.springframework.boot/groupId artifactIdspring-boot-maven-plugin/artifactId /plugin /plugins /build/project weblog-admin?xml version=1.0 encoding=UTF-8?project xmlns=http://maven.apache.org/POM/4.0.0 xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion4.0.0/modelVersion !-- 指定父项目为 weblog-springboot -- parent groupIdcom.sakurasep/groupId artifactIdweblog-springboot/artifactId version$revision/version /parent groupIdcom.sakurasep/groupId artifactIdweblog-admin/artifactId nameweblog-admin/name descriptionweblog-admin (负责管理后台相关功能)/description dependencies dependency groupIdcom.sakurasep/groupId artifactIdweblog-common/artifactId /dependency !-- 免写冗余的 Java 样板式代码 -- dependency groupIdorg.projectlombok/groupId artifactIdlombok/artifactId optionaltrue/optional /dependency !-- 单元测试 -- dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-test/artifactId scopetest/scope /dependency /dependencies/project weblog-common?xml version=1.0 encoding=UTF-8?project xmlns=http://maven.apache.org/POM/4.0.0 xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion4.0.0/modelVersion parent groupIdcom.sakurasep/groupId artifactIdweblog-springboot/artifactId version$revision/version /parent groupIdcom.sakurasep/groupId artifactIdweblog-common/artifactId nameweblog-common/name descriptionweblog-module-common (此模块用于存放一些通用的功能)/description dependencies !-- 免写冗余的 Java 样板式代码 -- dependency groupIdorg.projectlombok/groupId artifactIdlombok/artifactId optionaltrue/optional /dependency !-- 单元测试 -- dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-test/artifactId scopetest/scope /dependency !-- AOP 切面 -- dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-aop/artifactId /dependency !-- Jackson -- dependency groupIdcom.fasterxml.jackson.core/groupId artifactIdjackson-databind/artifactId /dependency /dependencies/project 测试项目执行 mvn clean 执行 mvn package 运行该 Spring Boot 项目，在 weblog-web 找到 WeblogWebApplication 启动类 运行在 8080 端口 Spring Boot 多环境配置多环境配置文件在 weblog-web 添加多环境配置文件 application.yml 用于默认配置 application-dev.yml 用于开发环境 application-test.yml 用于测试环境 application-prod.yml 用于生产环境 相比于 properties 格式的配置文件，yaml 格式的显然可阅读性更好 在默认配置文件中激活 dev 环境 启动项目测试，出现以下标注语句表示激活成功 配置 LombokLombok 的优点 简化 Getter 和 Setter 方法： 在传统的 Java 开发中，你经常需要为每个类的属性手动编写 Getter 和 Setter 方法，但是有了 Lombok，你只需要在属性上加上@Getter和@Setter注解，Lombok 就会为你自动生成这些方法。 自动生成构造函数： 通过@NoArgsConstructor %、% copy @RequiredArgsConstructor或@AllArgsConstructor注解，你可以快速生成无参构造函数、带有必需参数的构造函数或者带有全部参数的构造函数。 自动生成 equals 和 hashCode 方法： 通过@EqualsAndHashCode注解，Lombok 会根据类的字段自动生成equals()和hashCode()方法，让你的类更易于比较和使用在集合中。 日志记录更轻松： 使用@Slf4j注解，你可以直接在类中使用log对象，而无需手动创建日志记录器。 简化异常抛出： 通过@SneakyThrows注解，你可以在方法中抛出受检异常，而无需显式地在方法上声明或捕获它们。 数据类简化： 使用@Data注解，Lombok 会为你自动生成所有常用方法，如 Getter、Setter、","tags":["SpringBoot","后端","Java","Maven"],"categories":["项目开发日记"]},{"title":"准备本地开发环境","path":"/posts/Xiaoha_Blog_01/","content":"准备本地开发环境环境准备基础环境系统: macOS Sonoma 14.3包管理器: homebrew 4.2.2 后端开发IDE: IDEA 2023.1.3数据库可视化: Navicat 16java管理程序: JenvJDK: openjdk1.8mysql: 5.7Maven: 3.9.6 前端开发IDE: VsCodeNodejs: 16","tags":["SpringBoot","后端","Java","Maven"],"categories":["项目开发日记"]},{"title":"适用于 Stellar 的标签转换脚本","path":"/posts/md-to-stellar/","content":"一、图片标签测试1.1 image ⇄ 图片超链接 1.2 galley 标签内不进行修改@test 二、一级标题测试2.1 quot ⇄ 一级标题一级标题转换成quot二级标题不转换三级标题不转换四级标题不转换五级标题不转换六级标题不转换三、无序列表测试3.1 radio ⇄ 无序列表 无序列表1 无序列表2 无序列表3 无序列表4 无序列表5 四、引用标签测试4.1 note ⇄ 引用 引用标签转换成为note 引用标签转换成为note 五、超链接测试5.1 link ⇄ 超链接上杉九月的博客 六、单行代码测试6.1 copy ⇄ 单行代码 6.2 代码块不转换#includeiostreamusing namespace std;int main()\tcout Hello world;return 0;","tags":["python","markdown","stellar","标准化"],"categories":["零基础教程"]},{"title":"媒体库使用指南","path":"/posts/How-To-Use-MediaServer/","content":"一、媒体库介绍目前在服务器上同时运行着两个媒体库，一个是我自行搭建的，使用 NASTools 和 AutoBangumi 进行媒体管理和追番自动化的本地库（以后简称本地库）。 1. 本地库1.1 本地库的优点 可以通过微信或者 Telegram 进行交互，一键下载入库你想看的影片 使用 AIO 服务器的核显进行解码，理论上支持所有硬件的播放 在外观看如果流量不足可以使用转码功能，将高码率的视频转成较低码率以降低流量消耗（因为有些 4K 电影原盘的码率可能平均 30Mbs ，也就是正常的 5G 网速才能够跑满） 支持实时更新蜜柑计划上的新番，基本做到制作组发布后几个小时内获取到新番 支持Infuse，iOS Apple TV macOS 设备推荐使用 Infuse，价格便宜，效果更好 1.2 本地库的缺点 外网上传带宽取决于我家里宽带的上传带宽，目前是 50Mbps，无法实现多人流畅观看 4K 电影原盘，后续我会将部分影片上传到阿里云盘，以获取直链加速外网播放速度 资源较少，目前收录的内容见媒体库收录存档，后续会逐渐增加存量，明年会将硬盘阵列升级到 8x8TB 的机械硬盘阵列，目前存储空间为 14TB 2. 网络库一个是网上最全，更新相对及时的小雅媒体库，它的环境是通过阿里云盘转存小雅保存好的文件，然后导入小雅刮削好的元数据，实现资源以媒体库的形式展示出来（以下简称网络库）。 2.1 网络库的优点 全网最全的影视资源，基本没有你想不到的 访问速度取决于阿里云盘的下载速度，我是阿里云盘的会员，理论上能跑满 500Mbps 的宽带 更新速度尚可，小雅媒体库算是一个公益，持续，稳定的媒体库了 2.2 网络库的缺点 Infuse 请不要使用小雅媒体库，因为会出现奇奇怪怪的 bug 小雅提供的 Emby 容器我个人并没有配置转码，在某些设备（例如直接使用网页）上可能无法播放 新番没有实时更新，目前最新的是 2023 年冬季动漫，还没有更新 2024 年春季动漫 有些 bug 我是修不了的，因为同步文件和数据不是由我管理，需要等待脚本更新 二、媒体库的使用1. 如何观看媒体库中的影片十分不推荐使用网页端，因为网页端无法调用本机进行解码，会导致观看所有资源都会通过服务器进行转码，大大消耗了服务器的资源。 0318 客户端资源仅用于学习交流，所有资源来自于以下Telegram频道。你可以通过源 TG 频道下载，也可以通过我提供的网盘下载 Emby学习小秘 1.1 Windows 用户Windows 的使用很方便，下载开心版的客户端即可 Windows开心版 安装结束后有一个配置和卸载工具，可以执行命令针对客户端进行修改，Windows 的玩法是最多的 安装完成打开客户端，输入服务器地址以及账号密码，即可进行观看 1.2 macOS 用户使用 Electron 版（次优）macOS Electron Emby 使用 Emby 官方客户端 （不推荐） 注意事项 使用脚本破解很容易失效，为了 Emby 这官方客户端的效果花 30 一个月买订阅又不值得。故不推荐使用，破解成功的话千万不要升级，因为很难说升级后脚本还能不能适配 在 App Store 下载 Emby 在终端输入 /bin/bash -c $(curl -fsSL https://raw.githubusercontent.com/psychopasss/ss_rule/main/macOS/EmbyUnlock.sh) 脚本输出 输入服务器地址进入首页，正常播放 如果弹出付费订阅验证，请关闭代理以及重新运行脚本 使用第三方客户端 Infuse （付费优选） 小雅 Emby 不要添加到Infuse!!! Infuse 的扫库会使得 小雅请求阿里云盘的 token 过量，从而失效 相比于付费给 Emby，Infuse 的会员价格更适合，并且是全平台，你的 iPad iPhone macOS AppleTV 都只需要购买一次订阅就可以全平台享受，价格也不贵，月费 13 元（之前 7 元），年费 88，总之还是挺实惠的。 我一直在用 Infuse 就是因为 Infuse 界面确实好看，等之后买了 AppleTV 也能顺畅使用。 从 App Store 下载 Infuse 打开后在文件-新增文件来源 添加服务器 在 其他 Emby... 这里添加服务器地址，选择媒体库模式 添加后等待 Infuse 扫库刮削媒体信息，刮削完成在首页变便会显示内容 使用 VidHub（不推荐） 注意，该播放器最近被发现禁止播放无版权内容，作为一个本地播放器使用联网权限来限制保存的视频，严重影响对该软件的信任，所以请不要使用这款软件 VidHub 连接到媒体服务器貌似不会扫库，是直接获取源服务器的信息，所以说小雅应该是可用的 VidHub 是一款免费的国产播放器，最近才听说，试着用了用还是挺不错的，后续更新对更多片源格式的支持后应该会能和 Infuse 刚一刚。 在 App Store 下载 VidHub VidHub 也支持两种添加方式 第一种是针对你没有媒体库管理软件，使用 bt 下载电影或是云盘转存电影，此时可以使用文件源 第二种是针对有媒体库的用户，这里我们就选择第二种方式 连接成功后点击已连接的服务器 剧集界面 1.3 Android 用户目前安卓上有两个版本，一个是常规版，一个是 MIUI 特供版，两者在界面上没有什么区别，特供版改成了小米视频的包名，用于启动视频工具箱里的补帧功能 MIUI特供版 该版本是为了支持MIUI 12.xx 骁龙8xx平台专属的动态画面补偿（视频补帧）功能而做修改，并添加了开心整合包内容，详细修改见频道记录。 Android 普通版 MIUI特供版 1.4 IOS 用户 注意 因为官方版的 Emby 破解过于麻烦，需要使用到圈 X，圈 X 还是挺贵的，有这钱还不如去买 Infuse 使用 Infuse从 App Store 下载 Infuse 如果你在 macOS 已经配置过了，iPad 端会云同步你的连接信息 如果没有配置，点击主页的设置，和 macOS 端一样的配置方法 软件首页 媒体信息页 使用 VidHub从 App Store 下载 VidHub 同样的，VidHub 也有云端同步功能，他的配置方法和 macOS 仍然保持相同 效果展示 软件首页和媒体信息页 1.5 Android TV 用户手里没有，大概介绍一下安装流程。 下载电视版本的 Emby 客户端 一般来说将安装包拷贝到 U盘，然后进入电视中安装（有些电视不允许安装第三方应用，这样的话需要打开 adb 调试，然后在同一个局域网内进行 adb 安装，这个我们以后再说） 打开应用，输入服务器地址和账号密码进行观看 Android TV 通用版 1.6 Apple TV 用户手里没有，大概介绍一下安装流程。 登录外区 Apple ID 账号，一般来说美区就可以，下载 Infuse 或者 VidHub 输入服务器地址和账号密码进行观看 2. 如何搜索你想看的内容因为我使用了 Nastool 作为媒体库管理工具，所以在这里实现了两种交互方式，企业微信和 Telegram。企业微信供内部交流使用，开放给大家的是 Telegram 群组 添加 Telegram 群组 和 Telegram BotBot @sakurasep_nastool_bot Channel 注意事项 Bot 是用于发送消息与媒体管理服务进行交互的，Channel 是接受消息通知的。 获取 ID 并 添加权限如果想使用交互请加我的 TG 进行私聊，发给我你的 ID，以下是 ID 获取方法 获取 ID 的 bot @getidsbot 添加后输入 /start 开始 使用方法找到刚才添加的媒体管理 bot 直接发送你想看的片名，注意，近期上映的院线影片在下线前不会搜到。 点击链接可以查看影片详细的信息，确认无误后发送序号自动开始下载入库，根据下载的大小和做种人数，基本热门的都能在几个小时内完成下载。 入库成功 此时 Emby 服务器中便有了水浒传 三、动漫归档计划相比于非动漫来说，我认为小雅媒体库做的已经很好了，唯独对于动漫这方面来说小雅内容并不是特别优质。 目前的进度 1. 20242024 春季新番 2. 20232023 冬季未完结 2023 冬季完结 目前我想的是把以往年份的有趣的动漫都归档到本地以及云盘中，我个人有阿里云盘12T，Onedrive E5 开发者账号，也就是 25个子账户，每个账户 5T Onedrive 现在的想法是本地和阿里云盘存一份热门动漫，在Onedrive 中尽量存储能获取的所有内容。 如果你能够提供容灾的云盘空间或是有时间对媒体库进行整理下载，欢迎在 TG 联系我。 四、媒体库更新日志因为时间原因，更新图片大概一个月一次，请查看下面的索引 - 动画电影 - 哪吒闹海 (1979) [TMDB:74037] [IMDB:tt0354770] - 风之谷 (1984) [TMDB:81] [IMDB:tt0087544] - 天空之城 (1986) [TMDB:10515] [IMDB:tt0092067] - 萤火虫之墓 (1988) [TMDB:12477] [IMDB:tt0095327] - 龙猫 (1988) [TMDB:8392] [IMDB:tt0096283] - 魔女宅急便 (1989) [TMDB:16859] [IMDB:tt0097814] - 狮子王 (1994) [TMDB:8587] [IMDB:tt0110357] - 侧耳倾听 (1995) [TMDB:37797] [IMDB:tt0113824] - 幽灵公主 (1997) [TMDB:128] [IMDB:tt0119698] - 未麻的部屋 (1998) [TMDB:10494] [IMDB:tt0156887] - 千与千寻 (2001) [TMDB:129] [IMDB:tt0245429] - 怪兽电力公司 (2001) [TMDB:585] [IMDB:tt0198781] - 冰川时代 (2002) [TMDB:425] [IMDB:tt0268380] - 东京教父 (2003) [TMDB:13398] [IMDB:tt0388473] - 哈尔的移动城堡 (2004) [TMDB:4935] [IMDB:tt0347149] - 穿越时空的少女 (2006) [TMDB:14069] [IMDB:tt0808506] - 红辣椒 (2006) [TMDB:4977] [IMDB:tt0851578] - 崖上的波妞 (2008) [TMDB:12429] [IMDB:tt0876563] - 机器人总动员 (2008) [TMDB:10681] [IMDB:tt0910970] - 玛丽和马克思 (2009) [TMDB:24238] [IMDB:tt0978762] - 飞屋环游记 (2009) [TMDB:14160] [IMDB:tt1049413] - 你看起来好像很好吃 (2010) [TMDB:89825] [IMDB:tt1734113] - 借东西的小人阿莉埃蒂 (2010) [TMDB:51739] [IMDB:tt1568921] - 玩具总动员3 (2010) [TMDB:10193] [IMDB:tt0435761] - 神偷奶爸 (2010) [TMDB:20352] [IMDB:tt1323594] - 驯龙高手 (2010) [TMDB:10191] [IMDB:tt0892769] - 萤火之森 (2011) [TMDB:92321] [IMDB:tt2061702] - 大闹天宫 (2012) [TMDB:145954] [IMDB:tt11941418] - 疯狂原始人 (2013) [TMDB:49519] [IMDB:tt0481499] - 超能陆战队 (2014) [TMDB:177572] [IMDB:tt2245084] - 头脑特工队 (2015) [TMDB:150540] [IMDB:tt2096673] - 你的名字。 (2016) [TMDB:372058] [IMDB:tt5311514] - 疯狂动物城 (2016) [TMDB:269149] [IMDB:tt2948356]- 华语电影 - 英雄本色 (1986) [TMDB:11471] [IMDB:tt0092263] - 倩女幽魂 (1987) [TMDB:30421] [IMDB:tt0093978] - 阿飞正传 (1990) [TMDB:18311] [IMDB:tt0101258] - 牯岭街少年杀人事件 (1991) [TMDB:15804] [IMDB:tt0101985] - 纵横四海 (1991) [TMDB:47423] [IMDB:tt0101020] - 新龙门客栈 (1992) [TMDB:40213] [IMDB:tt0105859] - 唐伯虎点秋香 (1993) [TMDB:37703] [IMDB:tt0108289] - 喜宴 (1993) [TMDB:9261] [IMDB:tt0107156] - 射雕英雄传之东成西就 (1993) [TMDB:55157] [IMDB:tt0108074] - 霸王别姬 (1993) [TMDB:10997] [IMDB:tt0106332] - 青蛇 (1993) [TMDB:39915] [IMDB:tt0106559] - 九品芝麻官 (1994) [TMDB:55156] [IMDB:tt0110201] - 活着 (1994) [TMDB:31439] [IMDB:tt0110081] - 背靠背，脸对脸 (1994) [TMDB:295279] [IMDB:tt0109235] - 重庆森林 (1994) [TMDB:11104] [IMDB:tt0109424] - 阳光灿烂的日子 (1994) [TMDB:161285] [IMDB:tt0111786] - 饮食男女 (1994) [TMDB:10451] [IMDB:tt0111797] - 大话西游之月光宝盒 (1995) [TMDB:13345] [IMDB:tt0112778] - 大话西游之月光宝盒 (1995) [TMDB:13345] [IMDB:tt0112778] - 甜蜜蜜 (1996) [TMDB:37185] [IMDB:tt0117905] - 春光乍泄 (1997) [TMDB:18329] [IMDB:tt0118845] - 一一 (2000) [TMDB:25538] [IMDB:tt0244316] - 花样年华 (2000) [TMDB:843] [IMDB:tt0118694] - 鬼子来了 (2001) [TMDB:25838] [IMDB:tt0245929] - 无间道 (2002) [TMDB:10775] [IMDB:tt0338564] - 无间道2 (2003) [TMDB:11647] [IMDB:tt0369060] - 功夫 (2004) [TMDB:9470] [IMDB:tt0373074] - 可可西里 (2004) [TMDB:16074] [IMDB:tt0386651] - 疯狂的石头 (2006) [TMDB:45380] [IMDB:tt0843270] - 色·戒 (2007) [TMDB:4588] [IMDB:tt0808357] - 东邪西毒：终极版 (2009) [TMDB:1241825] - 岁月神偷 (2010) [TMDB:39693] [IMDB:tt1602572] - 让子弹飞 (2010) [TMDB:51533] [IMDB:tt1533117] - 心迷宫 (2014) [TMDB:292362] [IMDB:tt4078856] - 驴得水 (2016) [TMDB:421742] [IMDB:tt6167014] - 大佛普拉斯 (2017) [TMDB:475149] [IMDB:tt7010412] - 我不是药神 (2018) [TMDB:532753] [IMDB:tt7362036] - 飞驰人生 (2019) [TMDB:575219] [IMDB:tt9597190] - 三大队 (2023) [TMDB:1109586] [IMDB:tt28212677] - 年会不能停！ (2023) [TMDB:1173076] [IMDB:tt27922369]- 国产剧 - 唐人街探案2 (1) [TMDB:247773] [IMDB:tt22475188] - 射雕英雄传 (1983) [TMDB:104] [IMDB:tt0274839] - 红楼梦 (1987) [TMDB:7191] [IMDB:tt1162595] - 三国演义 (1994) [TMDB:72645] [IMDB:tt0108914] - 水浒传 (1998) [TMDB:78132] [IMDB:tt1388431] - 狂飙 (2023) [TMDB:210757] [IMDB:tt26235088] - 猎冰 (2024) [TMDB:233958]- 外语电影 - 城市之光 (1931) [TMDB:901] [IMDB:tt0021749] - 摩登时代 (1936) [TMDB:3082] [IMDB:tt0027977] - 乱世佳人 (1939) [TMDB:770] [IMDB:tt0031381] - 魂断蓝桥 (1940) [TMDB:43824] [IMDB:tt0033238] - 罗生门 (1950) [TMDB:548] [IMDB:tt0042876] - 雨中曲 (1952) [TMDB:872] [IMDB:tt0045152] - 罗马假日 (1953) [TMDB:804] [IMDB:tt0046250] - 七武士 (1954) [TMDB:346] [IMDB:tt0047478] - 十二怒汉 (1957) [TMDB:389] [IMDB:tt0050083] - 控方证人 (1957) [TMDB:37257] [IMDB:tt0051201] - 惊魂记 (1960) [TMDB:539] [IMDB:tt0054215] - 虎口脱险 (1966) [TMDB:8290] [IMDB:tt0060474] - 2001太空漫游 (1968) [TMDB:62] [IMDB:tt0062622] - 教父 (1972) [TMDB:238] [IMDB:tt0068646] - 飞越疯人院 (1975) [TMDB:510] [IMDB:tt0073486] - 美国往事 (1984) [TMDB:311] [IMDB:tt0087843] - 忠犬八公物语 (1987) [TMDB:31743] [IMDB:tt0093132] - 末代皇帝 (1987) [TMDB:746] [IMDB:tt0093389] - 天堂电影院 (1988) [TMDB:11216] [IMDB:tt0095765] - 雨人 (1988) [TMDB:380] [IMDB:tt0095953] - 死亡诗社 (1989) [TMDB:207] [IMDB:tt0097165] - 沉默的羔羊 (1991) [TMDB:274] [IMDB:tt0102926] - 终结者2：审判日 (1991) [TMDB:280] [IMDB:tt0103064] - 闻香识女人 (1992) [TMDB:9475] [IMDB:tt0105323] - 完美的世界 (1993) [TMDB:9559] [IMDB:tt0107808] - 辛德勒的名单 (1993) [TMDB:424] [IMDB:tt0108052] - 低俗小说 (1994) [TMDB:680] [IMDB:tt0110912] - 燃情岁月 (1994) [TMDB:4476] [IMDB:tt0110322] - 肖申克的救赎 (1994) [TMDB:278] [IMDB:tt0111161] - 这个杀手不太冷 (1994) [TMDB:101] [IMDB:tt0110413] - 阿甘正传 (1994) [TMDB:13] [IMDB:tt0109830] - 七宗罪 (1995) [TMDB:807] [IMDB:tt0114369] - 勇敢的心 (1995) [TMDB:197] [IMDB:tt0112573] - 情书 (1995) [TMDB:47002] [IMDB:tt0113703] - 爱在黎明破晓前 (1995) [TMDB:76] [IMDB:tt0112471] - 猜火车 (1996) [TMDB:627] [IMDB:tt0117951] - 千钧一发 (1997) [TMDB:782] [IMDB:tt0119177] - 小鞋子 (1997) [TMDB:21334] [IMDB:tt0118849] - 心灵捕手 (1997) [TMDB:489] [IMDB:tt0119217] - 泰坦尼克号 (1997) [TMDB:597] [IMDB:tt0120338] - 美丽人生 (1997) [TMDB:637] [IMDB:tt0118799] - 拯救大兵瑞恩 (1998) [TMDB:857] [IMDB:tt0120815] - 搏击俱乐部 (1999) [TMDB:550] [IMDB:tt0137523] - 第六感 (1999) [TMDB:745] [IMDB:tt0167404] - 绿里奇迹 (1999) [TMDB:497] [IMDB:tt0120689] - 菊次郎的夏天 (1999) [TMDB:4291] [IMDB:tt0199683] - 黑客帝国 (1999) [TMDB:603] [IMDB:tt0133093] - 西西里的美丽传说 (2000) [TMDB:10867] [IMDB:tt0213847] - 记忆碎片 (2000) [TMDB:77] [IMDB:tt0209144] - 人工智能 (2001) [TMDB:644] [IMDB:tt0212720] - 哈利·波特与魔法石 (2001) [TMDB:671] [IMDB:tt0241527] - 天使爱美丽 (2001) [TMDB:194] [IMDB:tt0211915] - 我是山姆 (2001) [TMDB:10950] [IMDB:tt0277027] - 指环王1：护戒使者 (2001) [TMDB:120] [IMDB:tt0120737] - 美丽心灵 (2001) [TMDB:453] [IMDB:tt0268978] - 上帝之城 (2002) [TMDB:598] [IMDB:tt0317248] - 哈利·波特与密室 (2002) [TMDB:672] [IMDB:tt0295297] - 指环王2：双塔奇兵 (2002) [TMDB:121] [IMDB:tt0167261] - 猫鼠游戏 (2002) [TMDB:640] [IMDB:tt0264464] - 谍影重重 (2002) [TMDB:2501] [IMDB:tt0258463] - 钢琴家 (2002) [TMDB:423] [IMDB:tt0253474] - 加勒比海盗1：黑珍珠号的诅咒 (2003) [TMDB:22] [IMDB:tt0325980] - 大鱼 (2003) [TMDB:587] [IMDB:tt0319061] - 指环王3：王者无敌 (2003) [TMDB:122] [IMDB:tt0167260] - 杀人回忆 (2003) [TMDB:11423] [IMDB:tt0353969] - 真爱至上 (2003) [TMDB:508] [IMDB:tt0314331] - 致命ID (2003) [TMDB:2832] [IMDB:tt0309698] - 黑客帝国2：重装上阵 (2003) [TMDB:604] [IMDB:tt0234215] - 黑客帝国3：矩阵革命 (2003) [TMDB:605] [IMDB:tt0242653] - 卢旺达饭店 (2004) [TMDB:205] [IMDB:tt0395169] - 哈利·波特与阿兹卡班的囚徒 (2004) [TMDB:673] [IMDB:tt0304141] - 幸福终点站 (2004) [TMDB:594] [IMDB:tt0362227] - 恋恋笔记本 (2004) [TMDB:11036] [IMDB:tt0332280] - 放牛班的春天 (2004) [TMDB:5528] [IMDB:tt0372824] - 无人知晓 (2004) [TMDB:2517] [IMDB:tt0408664] - 爱在日落黄昏时 (2004) [TMDB:80] [IMDB:tt0381681] - 电锯惊魂 (2004) [TMDB:176] [IMDB:tt0387564] - 蝴蝶效应 (2004) [TMDB:1954] [IMDB:tt0289879] - 谍影重重2 (2004) [TMDB:2502] [IMDB:tt0372183] - 傲慢与偏见 (2005) [TMDB:4348] [IMDB:tt0414387] - 哈利·波特与火焰杯 (2005) [TMDB:674] [IMDB:tt0330373] - 战争之王 (2005) [TMDB:1830] [IMDB:tt0399295] - 断背山 (2005) [TMDB:142] [IMDB:tt0388795] - 当幸福来敲门 (2006) [TMDB:1402] [IMDB:tt0454921] - 窃听风暴 (2006) [TMDB:582] [IMDB:tt0405094] - 致命魔术 (2006) [TMDB:1124] [IMDB:tt0482571] - 血钻 (2006) [TMDB:1372] [IMDB:tt0450259] - 香水 (2006) [TMDB:1427] [IMDB:tt0396171] - 地球上的星星 (2007) [TMDB:7508] [IMDB:tt0986264] - 谍影重重3 (2007) [TMDB:2503] [IMDB:tt0440963] - 遗愿清单 (2007) [TMDB:7350] [IMDB:tt0825232] - 入殓师 (2008) [TMDB:16804] [IMDB:tt1069238] - 朗读者 (2008) [TMDB:8055] [IMDB:tt0976051] - 本杰明·巴顿奇事 (2008) [TMDB:4922] [IMDB:tt0421715] - 步履不停 (2008) [TMDB:25050] [IMDB:tt1087578] - 浪潮 (2008) [TMDB:7735] [IMDB:tt1063669] - 穿条纹睡衣的男孩 (2008) [TMDB:14574] [IMDB:tt0914798] - 蝙蝠侠：黑暗骑士 (2008) [TMDB:155] [IMDB:tt0468569] - 贫民窟的百万富翁 (2008) [TMDB:12405] [IMDB:tt1010048] - 三傻大闹宝莱坞 (2009) [TMDB:20453] [IMDB:tt1187043] - 恐怖游轮 (2009) [TMDB:26466] [IMDB:tt1187064] - 无耻混蛋 (2009) [TMDB:16869] [IMDB:tt0361748] - 阿凡达 (2009) [TMDB:19995] [IMDB:tt0499549] - 告白 (2010) [TMDB:54186] [IMDB:tt1590089] - 怦然心动 (2010) [TMDB:43949] [IMDB:tt0817177] - 盗梦空间 (2010) [TMDB:27205] [IMDB:tt1375666] - 禁闭岛 (2010) [TMDB:11324] [IMDB:tt1130884] - 黑天鹅 (2010) [TMDB:44214] [IMDB:tt0947798] - 哈利·波特与死亡圣器(下) (2011) [TMDB:12445] [IMDB:tt1201607] - 我爱你 (2011) [TMDB:72575] [IMDB:tt1862020] - 源代码 (2011) [TMDB:45612] [IMDB:tt0945513] - 熔炉 (2011) [TMDB:81481] [IMDB:tt2070649] - 触不可及 (2011) [TMDB:77338] [IMDB:tt1675434] - 超脱 (2011) [TMDB:74308] [IMDB:tt1683526] - 3 (2012) [TMDB:79660] [IMDB:tt2123129] - 少年派的奇幻漂流 (2012) [TMDB:87827] [IMDB:tt0454876] - 蝙蝠侠：黑暗骑士崛起 (2012) [TMDB:49026] [IMDB:tt1345836] - 被解救的姜戈 (2012) [TMDB:68718] [IMDB:tt1853728] - 七号房的礼物 (2013) [TMDB:158445] [IMDB:tt2659414] - 彗星来的那一夜 (2013) [TMDB:220289] [IMDB:tt2866360] - 恐怖直播 (2013) [TMDB:209764] [IMDB:tt2990738] - 新世界 (2013) [TMDB:165213] [IMDB:tt2625030] - 时空恋旅人 (2013) [TMDB:122906] [IMDB:tt2194499] - 爱在午夜降临前 (2013) [TMDB:132344] [IMDB:tt2209418] - 素媛 (2013) [TMDB:255709] [IMDB:tt3153634] - 辩护人 (2013) [TMDB:242452] [IMDB:tt3404140] - 达拉斯买家俱乐部 (2013) [TMDB:152532] [IMDB:tt0790636] - 2 (2014) [TMDB:480682] [IMDB:tt3529830] - 小森林：夏秋篇 (2014) [TMDB:294682] [IMDB:tt3474600] - 布达佩斯大饭店 (2014) [TMDB:120467] [IMDB:tt2278388] - 星际穿越 (2014) [TMDB:157336] [IMDB:tt0816692] - 模仿游戏 (2014) [TMDB:205596] [IMDB:tt2084970] - 消失的爱人 (2014) [TMDB:210577] [IMDB:tt2267998] - 荒蛮故事 (2014) [TMDB:265195] [IMDB:tt3011894] - 一个叫欧维的男人决定去死 (2015) [TMDB:348678] [IMDB:tt4080728] - 小森林：冬春篇 (2015) [TMDB:336026] [IMDB:tt3474602] - 小萝莉的猴神大叔 (2015) [TMDB:348892] [IMDB:tt3863552] - 房间 (2015) [TMDB:264644] [IMDB:tt3170832] - 海蒂和爷爷 (2015) [TMDB:365045] [IMDB:tt3700392] - 海街日记 (2015) [TMDB:315846] [IMDB:tt3756788] - 火星救援 (2015) [TMDB:286217] [IMDB:tt3659388] - 疯狂的麦克斯4：狂暴之路 (2015) [TMDB:76341] [IMDB:tt1392190] - 聚焦 (2015) [TMDB:314365] [IMDB:tt1895587] - 完美陌生人 (2016) [TMDB:381341] [IMDB:tt4901306] - 摔跤吧！爸爸 (2016) [TMDB:360814] [IMDB:tt5074352] - 海边的曼彻斯特 (2016) [TMDB:334541] [IMDB:tt4034228] - 血战钢锯岭 (2016) [TMDB:324786] [IMDB:tt2119532] - 釜山行 (2016) [TMDB:396535] [IMDB:tt5700672] - 三块广告牌 (2017) [TMDB:359940] [IMDB:tt5027774] - 奇迹男孩 (2017) [TMDB:406997] [IMDB:tt2543472] - 看不见的客人 (2017) [TMDB:411088] [IMDB:tt4857264] - 请以你的名字呼唤我 (2017) [TMDB:398818] [IMDB:tt5726616] - 何以为家 (2018) [TMDB:517814] [IMDB:tt8267604] - 头号玩家 (2018) [TMDB:333339] [IMDB:tt1677720] - 小偷家族 (2018) [TMDB:505192] [IMDB:tt8075192] - 绿皮书 (2018) [TMDB:490132] [IMDB:tt6966692] - 阳光姐妹淘 (2018) [TMDB:517065] [IMDB:tt7493818] - 小丑 (2019) [TMDB:475557] [IMDB:tt7286456]- 新番 - 小不点 (1983) [TMDB:17400] [IMDB:tt0320055] - 青之驱魔师 (2011) [TMDB:38464] [IMDB:tt1799631] - 王者天下 (2012) [TMDB:46437] [IMDB:tt2404499] - 暗芝居 (2013) [TMDB:56559] [IMDB:tt3111906] - 欢迎来到实力至上主义的教室 (2017) [TMDB:72517] [IMDB:tt7263328] - 足球小将 (2018) [TMDB:77240] [IMDB:tt7784442] - 卡片战斗先导者overDress (2021) [TMDB:106301] [IMDB:tt13872472] - 弱势角色友崎君 (2021) [TMDB:99083] [IMDB:tt13103028] - 我被逐出队伍后过上慢生活 (2021) [TMDB:113256] [IMDB:tt13483212] - 月光下的异世界之旅 (2021) [TMDB:111819] [IMDB:tt13311344] - 新 福星小子 (2022) [TMDB:154524] [IMDB:tt16764368] - 不死不幸 (2023) [TMDB:209077] [IMDB:tt21927720] - 奇异贤伴 黑色天使 (2023) [TMDB:210181] [IMDB:tt24240038] - 广阔天空！光之美少女 (2023) [TMDB:213883] [IMDB:tt23862502] - 我心里危险的东西 (2023) [TMDB:207250] [IMDB:tt21423786] - 烈焰先锋：救国的橘衣消防员 (2023) [TMDB:223780] [IMDB:tt29201691] - 爱犬指令 (2023) [TMDB:229613] - 物理魔法使-马修- (2023) [TMDB:204832] [IMDB:tt21209804] - 狩火之王 (2023) [TMDB:156688] [IMDB:tt21912036] - 狩龙人拉格纳 (2023) [TMDB:195459] [IMDB:tt28685470] - 至高之牌 (2023) [TMDB:194665] [IMDB:tt25275610] - 药屋少女的呢喃 (2023) [TMDB:220542] [IMDB:tt26743760] - 葬送的芙莉莲 (2023) [TMDB:209867] [IMDB:tt22248376] - 逃走中 THE GREAT MISSION (2023) [TMDB:217388] - 香格里拉边境 (2023) [TMDB:205050] [IMDB:tt28776190] - Wonderful 光之美少女！ (2024) [TMDB:243216] [IMDB:tt30608459] - 为了在异世界也能抚摸毛茸茸而努力。 (2024) [TMDB:205672] [IMDB:tt30689225] - 事与愿违的不死冒险者 (2024) [TMDB:197848] [IMDB:tt30177477] - 休假日的坏人先生 (2024) [TMDB:222784] [IMDB:tt29467317] - 佐佐木与文鸟小哔 (2024) [TMDB:206630] [IMDB:tt27524116] - 公主殿下“拷问”的时间到了 (2024) [TMDB:229443] [IMDB:tt30643998] - 到了30岁还是处男，似乎会变成魔法师 (2024) [TMDB:237045] [IMDB:tt28369144] - 勇气爆发BangBravern (2024) [TMDB:238846] [IMDB:tt30975941] - 北海道辣妹贼拉可爱 (2024) [TMDB:213181] [IMDB:tt23029874] - 反派大小姐等级99～我是隐藏BOSS但不是魔王～ (2024) [TMDB:222930] [IMDB:tt30495119] - 外科医生爱丽丝 (2024) [TMDB:221310] [IMDB:tt28247170] - 婚戒物语 (2024) [TMDB:218493] [IMDB:tt30488398] - 异世界温泉开拓记 (2024) [TMDB:241021] [IMDB:tt30644058] - 异修罗 (2024) [TMDB:220286] [IMDB:tt26713948] - 愚蠢天使与恶魔共舞 (2024) [TMDB:231357] [IMDB:tt30495098] - 憧憬成为魔法少女 (2024) [TMDB:236338] [IMDB:tt29605390] - 我独自升级 (2024) [TMDB:127532] [IMDB:tt21209876] - 战国妖狐 (2024) [TMDB:234995] [IMDB:tt30325850] - 指尖相触，恋恋不舍 (2024) [TMDB:230059] [IMDB:tt30024091] - 挣扎吧，亚当 (2024) [TMDB:241002] - 无人能敌 (2024) [TMDB:226905] [IMDB:tt28454318] - 明治击剑－1874－ (2024) [TMDB:99787] [IMDB:tt30495035] - 最弱的驯养师开启的捡垃圾的旅途 (2024) [TMDB:214310] [IMDB:tt30644010] - 最强肉盾的迷宫攻略～拥有稀少技能体力9999的肉盾，被勇者队伍辞退了～ (2024) [TMDB:236532] [IMDB:tt30643971] - 月刊妄想科学 (2024) [TMDB:236142] [IMDB:tt30494894] - 治愈魔法的错误使用方法 (2024) [TMDB:131365] [IMDB:tt15237152] - 百千家的妖怪王子 (2024) [TMDB:230823] [IMDB:tt30691068] - 碰之道 (2024) [TMDB:234176] [IMDB:tt31309480] - 秒杀外挂太强了，异世界的家伙们根本就不是对手。 (2024) [TMDB:236144] [IMDB:tt30146725] - 轮回七次的恶役千金在前敌国享受随心所欲的新婚生活 (2024) [TMDB:232926] [IMDB:tt28685624] - 迷宫饭 (2024) [TMDB:207784] [IMDB:tt21621494] - 金属口红 (2024) [TMDB:222787] [IMDB:tt29510641] - 零食八江 (2024) [TMDB:236930] [IMDB:tt29474142] - 魔女与野兽 (2024) [TMDB:208445] [IMDB:tt30089363] - 魔都精兵的奴隶 (2024) [TMDB:139060] [IMDB:tt16156736]- 演唱会 - 音乐之声 (1965) [TMDB:15121] [IMDB:tt0059742] - 海上钢琴师 (1998) [TMDB:10376] [IMDB:tt0120731] - 千年女优：轨迹 (2001) [TMDB:968100] - 被嫌弃的松子的一生 (2006) [TMDB:31512] [IMDB:tt0768120] - 海豚湾 (2009) [TMDB:23128] [IMDB:tt1313104] - 海洋 (2010) [TMDB:36970] [IMDB:tt0765128] - 再次出发之纽约遇见你 (2013) [TMDB:198277] [IMDB:tt1980929] - 爆裂鼓手 (2014) [TMDB:244786] [IMDB:tt2582802] - 爱乐之城 (2016) [TMDB:313369] [IMDB:tt3783958] - 二十二 (2017) [TMDB:473267] [IMDB:tt3843282] - 寻梦环游记 (2017) [TMDB:354912] [IMDB:tt2380307] - 波西米亚狂想曲 (2018) [TMDB:424694] [IMDB:tt1727824] 1. 国产剧 2. 日韩剧暂无 3. 外语电影 4. 华语电影 5. 动画电影 6. 演唱会","tags":["Emby","Telegram","媒体库","Infuse"],"categories":["技术分享"]},{"title":"TeamSpeak使用指南","path":"/posts/TeamSpeak/","content":"一、为什么我们不再使用KOOKKOOK(原开黑啦),这款软件从开始发行就是抄袭国外的社群交流软件Discord,当他起初发行的时候,有高清的屏幕分享,良好的语音通话质量,还有很不错的AI降噪. 此外开黑啦在起初也是没有任何广告和会员特效. 但是随着免费高质量所积累的用户逐渐扩大,开黑啦担心侵权问题,随即改名KOOK,从此有了会员,语音质量和服务器助力包挂钩,添加了各种花里胡哨的特效,此外它的核心功能AI降噪也变成了每日120分钟体验. 可以说,KOOK将大多数国产软件先引流后狠狠收费的丑恶嘴脸表现到了极致. 虽然目前市面上还有很多语音软件,如vk老头的语音,黑盒语音,但是我们无法保证这些软件是否会走向KOOK的老路.因此,免费的TeamSpeak成为了我们的首选,它是各大电竞赛事的首选语音交流软件,如CSGO的Major等赛事.它的免费版支持最高7.71KiBs的音质,此外他的回声消除等功能有效的防止背景嘈杂的声音,它的频道也支持文字交流,相信这样一款专业简洁的语音交流软件可以成为我们今后开黑的神器! 二、如何使用TeamSpeak1. 下载与安装首先,请不要在百度中搜索下载,因为你大概率会进入TeamSpeak中文网,这是盗版网站,和Steam游戏管家是一个道理 TeamSpeak官方网站 从这里下载客户端即可. 点击下载后来到这个界面,选择TS3 Client,因为目前TS5的汉化还没有做好,TS3有完美汉化 然后就是正常进行安装,中途会问你时候安装overwolf,这个是TeamSpeak的插件,用于在游戏内显示当前频道是谁在讲话 2. 加入我的服务器根据下图所示填入服务器的名字,密码在群里,昵称改成你想显示的昵称,然后就可以连接了! 3. 如何配置TeamSpeak这是TeamSpeak的简洁UI 点开偏好设置,最重要的是以下两个设置,首先让我们来看音频输出设置 然后是音频输入设置,注意这里根据你实际情况调整消除背景噪音的强度以及语音识别的阈值 三、如何搭建一个TeamSpeak服务器如果是仅仅搭建一个稳定可靠的语音服务器,那使用Linux + Docker是最为稳妥的方案 1. 通过Docker安装(Linux)零基础教程面向的是普通用户,所以这里建议使用1Panel面板对Linux系统进行简单的可视化管理 四、结语相信到这里你就了解如何使用以及搭建属于你和你朋友自己的语音服务器,希望我的文章能帮助到你,下一篇文章再见!欢迎在评论区和大家交流你对TeamSpeak还有哪些有趣的玩法!","tags":["零基础","游戏"],"categories":["技术分享"]},{"title":"关于我","path":"/page/about/index.html","content":"早发白帝城李白朝辞白帝彩云间，千里江陵一日还。两岸猿声啼不住，轻舟已过万重山。一切都会变好的 21 岁，为梦想奋斗 爱好：ACGN，Coding，创作 喜欢：探索新奇的事物 目前在玩的游戏：各种二次元游戏，云顶之弈 & 金铲铲，各种沙盒类游戏 运动：散步，骑行 目标：人民教师||自由开发者||自媒体 希望拥有的技能：多国语言||美术设计||3D建模||项目开发 目前维护的网站 上杉九月的博客使用 Hexo + Stellar 搭建 我的推荐 图书音乐游戏最近正在看的书 test最近很喜欢的音乐 test最近在玩的有趣游戏 test 关于本站 你好，很高兴你能访问我的博客，从一开始的 next 主题，到 Butterfly、Volantis，最后我选择了这款简洁，阅读体验很棒的 Stellar 主题。在这里我会分享自己开发的项目，有趣的科技相关的内容，以及日常心得记录。很喜欢雷总的一句话“让每个人都能享受科技的乐趣”。我希望我的文章可以帮助到你。"},{"title":"我的朋友们","path":"/page/friends/index.html","content":"欢迎来访 无限进步 站点信息友链申请要求如何申请失效的链接title: 上杉九月的博客,url: https://blog.sakurasep.site/,avatar: https://bu.dusays.com/2023/03/13/640dfc9720adc.png,screenshot: https://bu.dusays.com/2024/03/08/65ead9bd5da28.png,description: 知识本就应该没有门槛，这才是互联网的意义HTTPS 站点 稳定的自有域名，这样才能说明你会坚持维护下去 能够坚持运营博客，半年内至少更新过 1-2 篇文章 请先将本站加入友链，然后提出申请本站有两种友链展示格式,如果你想要展示你网站的首页缩略图，请填写screenshot选项本站采用的是动态issue申请，请访问 https://github.com/sakurasep/Friends/issuesGithub Issue 按照模板添加友链申请。如果不方便打开Github。请在评论区按照本站信息模板留言，谢谢。暂无 以上内容的最后更新日期：2024年02月20日 朋友们"},{"title":"说说","path":"/page/memos/index.html","content":""},{"title":"源码分析","path":"/wiki/qfnuLibraryBook/code.html","content":"后续更新"},{"title":"项目介绍","path":"/wiki/qfnuLibraryBook/index.html","content":"曲Star图书馆预约程序注意事项 本项目目的是告别卡顿的预约界面，采用更快捷的方式自动预约座位。推荐使用云服务器，甚至路由的 openwrt 也可以运行本程序，实现24小时自动监控，预约成功后推送消息到 Telegram 或者发送到邮箱。希望预约后能够有效利用如此好的学习环境，这么好的环境不是让某些人谈恋爱和打游戏的欢迎提出修改建议，请在 issue 中进行交流本项目仅供交流学习，禁止将本项目用于商业行为 开发目的相比于校外收费的自习室，校内的图书馆光照条件更好，恒温 26°，更安静的环境，丰富的藏书。重要的是免费。对于找工作或者是考研的同学都是一个绝佳的学习环境。 对于如此好的环境，图书馆的预约界面访问逻辑混乱，并且经常出现无座的情况。为了实现自动化预约图书馆，特此编写了此程序，方便热爱学习的同学更方便获取优质的环境，实现自我提升。 贡献者感谢nakaii-002Qfnu_CAS_token提供的获取身份验证 Auth_Token 的代码 开源许可协议本项目是由 @上杉九月 设计和开发，采用了 @nakaii-002 的部分代码，使用 CC BY-NC 4.0 协议进行授权，拷贝、分享或基于此进行创作时请遵守协议内容： Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)This is a human-readable summary of (and not a substitute for) the license. You are free to:Share — copy and redistribute the material in any medium or formatAdapt — remix, transform, and build upon the materialThe licensor cannot revoke these freedoms as long as you follow the license terms.Under the following terms:Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.NonCommercial — You may not use the material for commercial purposes.No additional restrictions — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.Notices:You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation.No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material."},{"title":"更新日志","path":"/wiki/qfnuLibraryBook/update.html","content":"2024 年 3 月 8 日添加了自动获取 token 的代码，代码来自于nakaii-002十分感谢他的代码，使得本项目目前已经实现了全自动化重构大部分的代码逻辑，大大优化了代码的执行速度和发生错误的概率，不再保存 json 到本地，直接读取响应的内容并进行处理适配了 aes 加密，今天的版本是最后的开放源代码的版本，后续将会打包加密程序主要功能已经完善，有问题请提 issue2021 年 1 月 8 日新增了进程池，如果此时访问url获取请求较为缓慢，请增加进程数以获取更高的响应概率，但是请不要滥用，无端增加服务器压力，推荐进程在5-10最为合适优化了代码的退出逻辑，基本涵盖了我测试时遇见的场景，是的，做了不少错误处理优化了代码的可读性，到今天为止该项目基本上就告一段落了，还有一点问题，因为我不会写异步请求，所以用了多进程，可能并发性能不如异步，还有是有些对于json文件的读取并不是十分快速，暂时不优化了2021 年 1 月 6 日优化目录结构,将获取自习室的信息与抢座功能分离,采用新的执行逻辑重构大部分代码，增加了可读性，逻辑更加正确 Todo ListFeaturesAuth_Token的自动获取 指定位置预约 位置优选 多进程获取可用位置 Bugs修复aes加密导致程序的崩溃 优化了部分测试出的错误处理 优化代码逻辑"},{"title":"如何使用","path":"/wiki/qfnuLibraryBook/usage.html","content":"开始前的准备工作测试的环境Python 3.12.1（Python 3.7+）git 2.39.3pip 23.2.1macOS Sonoma 14.3 如果你使用的是 Python 3.12.1 那么在 根目录pymain 找到 requirements.txt然后运行以下命令即可一键配置依赖环境 macOS 使用 pyenv 管理 Python 环境1. brew 安装 pyenvbrew install pyenv 2. 配置环境变量，根据自己的终端类型将以下内容加入到对应文件.zshrc/.bashrcexport PYENV_ROOT=/usr/local/var/pyenvexport PATH=$PYENV_ROOT/bin:$PATHexport PATH=$PYENV_ROOT/shims:$PATHif which pyenv /dev/null; then eval $(pyenv init -); fi 检查是否安装成功pyenv 3. 使用 pyenv 安装 Python 3.12.0 安装Python的时候建议对终端进行代理 export https_proxyhttp://127.0.0.1:7890 http_proxyhttp://127.0.0.1:7890 all_proxysocks5:127.0.0.1:7890 pyenv命令# 显示可以安装的版本列表pyenv install -l# 安装指定版本的 Pythonpyenv install 3.12.0# 会在当前目录创建 .python-version 文件，并记录设置的 python 环境，每次进入该目录会自动设置成该 python 环境pyenv local 3.12.0# 安装依赖pip install -r requirements.txt 开始使用注意事项 进程数平常只需要1-2即可，只有压力比较大的时候才需要使用更高的进程数，但是也不需要超过3请不要在本机网络情况不好的时候使用，虽然报错不影响正常使用，程序的容错已经很不错了，但是我不想再反馈错误日志的时候看到因为网络问题导致的错误 使用 git clone 将整个项目克隆到本地 使用 cd 命令到 pymain 使用 python 运行程序 运行模式 优选模式 仅适用于西校区图书馆的三个自习室，个人优选了距离🚾近的和有插座的区域。注意优选模式为了速度无法提前筛选此座位是否已经被预约。 指定模式 请预先根据 jsonseat_info 中各个自习室的真实位置(‘name’)获取座位代号(‘id’)，请输入对应自习室的对应 id 默认模式 全随机预约，保证预约的时候此位置无人 可用教室（仅对于曲阜校区）西校区图书馆 西校区图书馆-三层自习室 西校区图书馆-四层自习室 西校区图书馆-五层自习室 西校区东辅楼 西校区东辅楼-二层自习室 西校区东辅楼-三层自习室 东校区图书馆 东校区图书馆-三层电子阅览室 东校区图书馆-三层自习室01 东校区图书馆-三层自习室02 东校区图书馆-四层中文现刊室 综合楼 综合楼-801自习室 综合楼-803自习室 综合楼-804自习室 综合楼-805自习室 综合楼-806自习室 行政楼 行政楼-四层东区自习室 行政楼-四层中区自习室 行政楼-四层西区自习室 电视台楼 电视台楼-二层自习室"},{"title":"我的手账","path":"/page/about/timeline/index.html","content":"我的说说 近期的 OKR 一、曲 Star 图书馆预约脚本 O1 曲阜师范大学图书馆预约脚本 解决有需求的同学抢不到心仪的座位，抢座时卡顿的问题 已完成 100% KR1 实现指定单个自习室随机抢座 已完成 100% KR2 实现程序的基础 UI 界面 目前暂时没有这个计划。应该是目前我不会写 延期 100% KR3 实现程序的基本功能 获取图书馆信息全随机抢座取消座位 已完成 100% KR4 新功能优化 实现自动获取 token筛选优质座位重新预约上次成功预约的座位 已完成 100% 二、转换脚本 O2 markdown 与 Stellar 标签互转 实现全自动化部署多平台的必备脚本，最终目标是实现一份标准 markdown 文件使用最少的步骤完成多平台部署 已完成 100% KR1 Python 脚本实现对 markdown 常用语法转换成 Stellar 的特色标签 图片标签转换成image标签无序列表转换成radio标签一级标题转换成quot标签引用转换成note标签超链接转换成link标签单行代码转换成copy标签 已完成 100% KR2 Python 脚本实现对 Stellar 的特色标签转换成 markdown 编辑器可视的标签 内容与上面的脚本效果相反，故省略。 已完成 100% KR3 脚本测试与修复 已完成 100% 三、重新设计频道宣传图 O3 重新设计频道宣传图 每篇文章下面的宣传图有些过时，更新一下 已完成 100% KR1 字体更换为得意黑 已完成 100% KR2 更换首推频道的平台 已完成 100% KR3 更换宣传图的背景图 已完成 100% 四、博客维护 O4 博客维护 博客好久没有维护了，彻底的维护一下 正常 73% KR1 阅读体验优化 文章格式修改阅读字体修改为 LXGW Screen 已完成 100% KR2 侧边栏优化 添加 memos 说说添加首页的 welcome 已完成 100% KR3 内容更新 关于页更新友链页更新手账页更新专栏内容更新wiki页更新过期文章重新优化 未完成 20% 五、新专栏文章 - 媒体库 O5 媒体库相关使用指南 针对服务器如何使用和搭建全自动化的媒体库，大概会出几篇教程 正常 0% KR1 文章封面 未完成 0% KR2 文章内容 媒体库的使用媒体库的基本搭建媒体库的进阶玩法 未完成 0%"},{"title":"我的朋友们","path":"/page/friends/rss/index.html","content":""}]